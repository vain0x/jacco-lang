// jaxxo 言語の "ungrammar" 構文定義ファイル
// ジャッコ言語の「他の言語になるべく似せる」という設計方針をもしやめたとしたら、どういう構文になるかの実験。
//
// "ungrammar" は <https://github.com/rust-analyzer/ungrammar> を参照。
// 同リポジトリにある Rust の構文定義を参考にしている。
//
// 凡例:
//
//   //          -- コメント
//   Name =      -- 非終端記号の定義 (リーフでないノード)
//   'ident'     -- 終端記号 (トークン)
//   A B         -- 連接。A, B がこの順番に出現すること
//   A | B       -- 選択。A, B のどちらか一方が出現すること
//   A*          -- 繰り返し。A が0回以上連続して出現すること
//   A?          -- 省略可能。A が0回または1回出現すること
//   (A)         -- カッコ。A と同じ
//   label:A     -- ラベル。A に 'label' という名前をつけたもの

// -----------------------------------------------
// リテラル
// -----------------------------------------------

Literal =
  'unit'
| 'true'
| 'false'
| 'number'
| 'char'
| 'string'

// -----------------------------------------------
// 名前
// -----------------------------------------------

// Qualifiable name.
Name =
  'ident' ('::' 'ident')*

// Unqualifiable name.
UnqualName =
  'ident'

// -----------------------------------------------
// 属性
// -----------------------------------------------

AttrItem =
  Name

Attr =
  '#' '[' AttrItem (',' AttrItem)* ','? ']'

// -----------------------------------------------
// 型
// -----------------------------------------------

Ty =
  InferTy
| NameTy
| GroupTy
| PtrTy
| ArrayTy
| SliceTy

InferTy =
  '_'

NameTy =
  Name

GroupTy =
  '(' Ty ')'

PtrTy =
  '*' ('const' | 'mut')? Ty

ArrayTy =
  '[' len:Expr ']' Ty

SliceTy =
  '[' ']' Ty

// -----------------------------------------------
// パターン
// -----------------------------------------------

Pat =
  LiteralPat
| DiscardPat
| NamePat
| RecordPat
| GroupPat

LiteralPat =
  Literal

DiscardPat =
  '_'

NamePat =
  Name

RecordPat =
  Name? '('
    fields:(RecordFieldPat (',' RecordFieldPat)* ','?)?
  ')'

RecordFieldPat =
  (UnqualName ':')? Pat

GroupPat =
  '(' Pat ')'

// -----------------------------------------------
// 式
// -----------------------------------------------

Expr =
  Literal
| NameExpr
| RecordExpr
| GroupExpr
| CallExpr
| IndexExpr
| FieldExpr
| RefExpr
| DerefExpr
| AsExpr
| UnaryOpExpr
| BinaryOpExpr
| BlockExpr
| BreakExpr
| ContinueExpr
| ReturnExpr
| IfExpr
| MatchExpr
| LoopExpr
| WhileExpr

Cond =
  Expr

NameExpr =
  Name

GroupExpr =
  '(' Expr ')'

Arg =
  (UnqualName ':')? Expr

CallExpr =
  Expr '(' args:(Arg (',' Arg)* ','?)? ')'

WithExpr =
  Expr 'with' '(' args:(Arg (',' Arg)* ','?)? ')'

IndexExpr =
  Expr '[' Expr ']'

FieldExpr =
  Expr '.' UnqualName

RefExpr =
  Expr '.' '&' ('const' |'mut')?

DerefExpr =
  Expr '.' '*'

AsExpr =
  Expr 'as' Ty

UnaryOpExpr =
  op:'-' Expr

BinaryOpExpr =
  left:Expr
  op:(
    '+' | '-' | '*' | '/' | '%'
    | '&' | '|' | '^' | '<<' | '>>'
    | '==' | '!=' | '<' | '>' | '<=' | '>='
    | '&&' | '||'
    | '<-'
    | '+=' | '-=' | '*=' | '/=' | '%='
    | '&=' | '|=' | '^=' | '<<=' | '>>='
  )
  right:Expr

BlockExpr =
  '{'
    decls:Decl*
  '}'

BreakExpr =
  'break' Expr?

ContinueExpr =
  'continue'

ReturnExpr =
  'return' Expr?

IfExpr =
  'if' Cond body:BlockExpr
  ('else' alt:(IfExpr | BlockExpr))?

MatchExpr =
  'match' Cond '{' Arm* '}'

Arm =
  Pat '=>' Expr ','?

LoopExpr =
  'loop' BlockExpr

WhileExpr =
  'while' Cond BlockExpr

// -----------------------------------------------
// 宣言
// -----------------------------------------------

Decl =
  AttrDecl
| ValDecl
| ConstDecl
| StaticDecl
| FnDecl
| EnumDecl
| StructDecl
| TypeDecl
| UseDecl

Vis =
  'priv'
| 'pub'

AttrDecl =
  '#' '!' '[' AttrItem (',' AttrItem)* ','? ']'

ValDecl =
  Attr* Vis?
  'val' Pat (':' Ty)? ('=' init:Expr)? ';'

ConstDecl =
  Attr* Vis?
  'const' Param ';'

StaticDecl =
  Attr* Vis?
  'static' Param ';'

Param = UnqualName ':' Ty ('=' init:Expr)?

FnDecl =
  Attr* Vis?
  'fn' UnqualName
  '(' params:(Param (',' Param)*)? ','? ')'
  ('->' Ty)?
  (
   '=' 'extern'
  | body:BlockExpr
  | ';'
  )

ConstVariantDecl =
  UnqualName (':' Ty)? ('=' init:Expr)?

FieldDecl =
  'val' Param

RecordVariantDecl =
  UnqualName '('
    fields:(FieldDecl (',' FieldDecl)* ','?)?
  ')'

VariantDecl =
  ConstVariantDecl
| RecordVariantDecl

ConstEnum =
  Attr* Vis?
  'const' 'enum' UnqualName
  (':' repr:Ty)?
  '{'
    (ConstVariantDecl (',' ConstVariantDecl)* ','?)?
  '}'

EnumDecl =
  Attr* Vis?
  'enum' UnqualName '{' (VariantDecl (',' VariantDecl)* ','?)? '}'

StructDecl =
  Attr* Vis?
  'struct' VariantDecl? ';'?

TypeDecl =
  Attr* Vis?
  'type' UnqualName '=' Ty ';'

UseDecl =
  Attr* Vis?
  'use' Name ';'

RootDecl =
  Decl*
