# 字句解析

WIP

字句解析は、文字列として与えられたソースコードをトークンの列に変換する。トークンは後続の工程で「基本的に1つのものとして扱われる」単位であり、主に以下の種類がある。

- EOF: 入力の終端
    - 必須ではないが、構文解析時の番兵として便利
- トリビア: 構文的に意味を持たない部分
    - 空白 (\x20, \t)
    - 改行 (\n, \r\n)
    - コメント (`// ...` や `/* ... */`)
    - 解釈不能 (ヌル文字、ソースコードの文字列エンコーディングに違反している部分、ソースコードの地の文に出現しえない文字など)
        - BOM
        - shebang (`#!/bin/sh`)
- リテラル:
    - 数値リテラル: 42 とか `0.314e+1` とか
    - 文字リテラル: `'a'` など
    - 文字列リテラル: `"hello"` など
- 識別子:
    - キーワードや予約語である識別子
        - `fn` など
    - キーワードでない識別子
        - `f` など
- 記号
    - `+` や `+=` など

注意: トークンは「分解不能な単位」ではない。例えば数値リテラル `3.14` は「整数部 `3`, 小数点 `.`, 小数部 `14`」と分解できる。とはいえ、この分解が必要になる機会は少ないのでその都度分解すればよい。また、数値リテラルを複数のトークンに分けてしまうと構文解析において邪魔になる。そのため、利便性を優先して1個のトークンとみなす。

## トークン列のイメージ

字句解析の目的は文字列をいくつかの区間に分割し、それぞれの区間のトークンとしての種類を特定すること。

例:

```
    fn main() {}

^^^^ 空白
    ^^ キーワード(fn)
      ^ 空白
```

```
(続き)
    fn main() {}
       ^^^^ 識別子
           ^ 左丸カッコ
            ^ 右丸カッコ
             ^ 空白
```

```
(続き)
    fn main() {}
              ^ 左波カッコ
               ^ 右波カッコ
                | EOF
```
