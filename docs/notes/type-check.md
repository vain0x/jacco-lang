# 型検査 (型推論)

WIP

構文から式やシンボルの型を計算し、検査する処理を型検査 (あるいは型推論) と呼んでいる。

型検査には検査と計算の2つの目的がある:

- 型つけ規則に違反する式を発見し、コンパイルエラーを報告する。
- ローカル変数などの型注釈を持たないシンボルの型を決定する。

型検査の前提となる言語の性質がある:

- エイリアスとローカル変数以外のシンボルの型はすべて型注釈が必須であり、型を推論する必要はない。
    (関数のパラメータや結果の型、構造体のフィールドの型など。クロージャを導入したらこの前提は崩れる。)

型検査の戦略は基本的に、式を評価順にみていき、それぞれの式の型を貪欲に決めていく。ただし部分的に、評価の「結果」側から式の型を決定する部分もある。

### シンボルの宣言の型

fn 宣言などにより定義される、シンボル本来の型を宣言の型と呼ぶ。
例えば `extern fn abort() -> never` の宣言の型は `fn() -> never` という矢印型になる。

宣言の型は式の型とは異なる可能性がある。
例えば後述の never 型に関する規則のため、`abort() as i32` における `abort` の「式の型」は `fn() -> i32` になる。

### 具体的な型

以下の型は具体的な型と呼ぶ。

- never, unit, bool
- `*unknown`, `*mut unknown`
- 数値型 (iNN, uNN, fNN, cNN)
- enum, struct で定義されるシンボルの型
- 具体的な型へのポインタ型 (`*i32`, `*mut i32` など)
- 具体的な型からなる矢印型 (`fn() -> i32` など)
- 具体的な型に解決されたメタ型変数

unknown と、具体的な型に解決されていないメタ型変数は具体的な型ではない。

### 型の制約

- 同一性の制約: ある2つの式が同じ型を持つこと。
    例えば `if { x } else { y }` の `x`, `y` は同じ型でなければいけない。
- キャスト可能性の制約: 式の型がある型へキャスト可能であること。
    例えば `x as i32` の式 x は、型 i32 へのキャストが可能な型を持たなければいけない。
- その他の制約: ある式がいくつかの種類の型のどれかを持つこと。
    例えば `x + y` のとき x はポインタ型か数値型でなければいけない。

### 単一化

TBD

### never に関する規則

ある式の型が T に解決されたとき、T 自身または T の共変の位置に出現する never をそれぞれフレッシュな型変数で置き換える。
(never <: T の部分型つけをシミュレートするため。)

これはすべての式の型解決後に適用されるが、実際にはシンボルの宣言の型と、関数呼び出しの結果型、ジャンプ式の型にしかそのような never は出現しないはず。

#### 例1: 結果型が never な関数の呼び出しの型つけ

```rust
fn yes() -> never {
    loop {}
}

pub fn main() -> i32 {
    no_return()
}
```

yes の宣言の型は `fn() -> never` なので、式 `yes()` における yes にはこの型がつく。
never が共変の位置に出現しているので、フレッシュな型変数 T を導入して、`yes: fn() -> T` となる。
単一化により T = i32 となり、型検査が通る。
最終的に `yes: fn() -> i32` になっていることに注意。(宣言の型と異なる。実行時に問題は起きない。)

#### 例2: 「結果型が never である関数」を受け取る関数の呼び出しの型付け

(ジャッコ言語の構文的に関数に関数を渡すことはできないが、中間表現ではこのような状況が発生する。)

```rust
fn jump(k: fn() -> never) -> never {
    k()
}

fn one() -> i32 {
    1
}

pub fn main() -> i32 {
    let _ = jump(yes); // OK
    let _ = jump(one); // NG
    0
}
```

式 `jump(yes)` における式 jump, yes の型は以下の通り
(T, U はそれぞれフレッシュな型変数):

- jump: `fn(fn() -> never) -> T`
- yes: `fn() -> U`

なお jump の引数 k の結果型である never は、共変の位置ではないので型変数に置き換えられない。
U = never と単一化して、型検査が通る。

一方、式 `jump(one)` は型検査を通らない。この式における式 jump, one の型は以下の通り:

- jump: `fn(fn() -> never) -> T`
- one: `fn() -> i32`

never != i32 なので単一化に失敗する。
実際、この呼び出しができてしまうと、結果が never なはずの jump が return してしまう。
すなわち、共変でない位置に出現する never を型変数に置き換えると、不正なコードが型検査を通ってしまう。

### unknown に関する規則

ある式の型が T に解決されたとき、T の反変の位置に出現する unknown をそれぞれフレッシュな型変数で置き換える。
(T <: unknown の部分型つけをシミュレートするため。)

never と同様。

```rust
extern fn malloc() -> *mut unknown;
extern fn free(p: *mut unknown);

pub fn main() -> i32 {
    let p = malloc(8) as *mut i32;
    free(p);
    0
}
```

`malloc(8)` における式の型は `fn() -> *mut unknown` である。
(unknown は不変の位置に出現しているので型変数に置換されない。)

`free(p)` における free の式の型は `fn(p: *T)` になり、T = i32 に単一化されて型検査を通る。
なお p の型に mut がついていないとき、`*mut T` に `*i32` は単一化できないので、型検査が通らない。

### リテラル

unit は unit 型、true, false は bool 型。

数値リテラル、文字リテラル、文字列リテラルの型は、型接尾辞 (`42_i32` みたいなの) がついているときは、その型になる。

そうでなければ、構文的に確定しない。以下の制約を持つ:

- 数値リテラルの型は数値型 (iNN, uNN, fNN, cNN のいずれか) でなければいけない。
- 小数部か指数部を持つ数値リテラルの型は浮動小数点数型 (fNN) でなければいけない。
- 文字リテラルの型は文字型 (cNN) でなければいけない。
- 文字列リテラルの型は文字型への読み取り専用ポインタ (`*cNN`) でなければいけない (?)
    - FIXME: 可能なら `Str` などの構造体に推論する規則のほうがよい (?)

直接の親となる式や宣言からリテラルの型が決まらないとき、リテラルの型は解決できない。

### 識別子・パス

シンボルに解決された識別子やパスの式には、そのシンボルの宣言の型がつく。

### レコード式

`T { f1: x1, ... }`

- フィールドに割り当てる式の型は、そのフィールドと同じ型でなければいけない。
- 結果は T になる。

### フィールド式

`x.a`

x は名前が a であるフィールドを持つレコードの型でなければいけない。
結果はそのフィールドの宣言の型になる。

### 関数呼び出し

`f(x1, y1, ...)`

- f は矢印型でなければいけない。
- 引数は、対応するパラメータと同じ型でなければいけない。
- 結果は関数の結果型になる。

### 添字式

`x[i]` は `*(x + i)` と同じ規則に従う。

### キャスト

`x as T` は以下のルールに従う。

- T が具体的な型でないとき:
    - x の型は T と同じでなければいけない。
- T が具体的な型のとき:
    - x の型が未束縛のメタ型変数なら、T を束縛する。
    - x の型は T にキャスト可能な型でなければいけない。

キャスト可能の条件:

- 任意の型 T は T 自身にキャスト可能 (反射性)
- never は T にキャスト可能
- 型 T は unit にキャスト可能
- bool, iNN, uNN, cNN, fNN はすべて相互にキャスト可能
- ポインタ型とポインタサイズの整数型はすべて相互にキャスト可能
- const enum 型は iNN, uNN にキャスト可能

### 単項演算

- `!x`: x は bool 型、結果も bool 型。
- `-x`: x は整数型でなければいけない。結果は同じ型になる。
- `*p`: p はポインタ型 `*T` または `*mut T` でなければいけない。結果は T になる。
- `&x`: x の型を T とするとき、結果は `*T` になる。x は可変な式でなければいけない。
- `&mut x`: x の型を T とするとき、結果は `*mut T` になる。

### 二項演算

- `x + y`, `x - y`:
    - x がポインタ型なら、y は整数型でなければいけない。結果は x の型になる。
    - そうでなければ、x, y は同じ型で、さらに数値型でなければいけない。結果はその型になる。
- `x * y`, `/`, `%`:
    - 左右が同じ型で、さらに数値型でなければいけない。結果はその型になる。
- ビット演算:
    - 左右が同じ型で、fNN ではない数値型でなければいけない。結果はその型になる。
- `==`, `!=`:
    - 左右が同じ型で、同値比較が可能な型でなければいけない。結果は bool になる。
- 順序の比較 (`<` など):
    - 左右が同じ型で、順序比較が可能な型でなければいけない。結果は i32 になる。
- 論理演算
    - `x && y`: `if x { y } else { false }` と同じ規則に従う。
    - `x || y`: `if x { true } else { y }` と同じ規則に従う。

同値比較が可能な型の条件:

- bool, 数値型, const enum
- (TODO: 同値比較が可能な型からなるレコード？)

順序比較が可能な型の条件:

- bool, 数値型, const enum
- (TODO: 順序比較が可能な型からなるレコード？)

### 代入

- `x = y`: x, y は同じ型でなければいけない。
- `x += y` など: 二項演算と同様

### ブロック

`{ d1; d2; ...; x }`

- 宣言が含まれていないか、最後の宣言が式宣言でないとき:
    - 結果は unit である。
- 最後の宣言が式宣言のとき:
    - 結果はその式の結果型と同じ。

### ジャンプ

break, continue, return の結果は never 型になる。
(never に関する規則によりフレッシュな型変数に置き換わる。)

- break: 引数は、対応するループの結果と同じ型でなければいけない。
- return: 引数は、対応する関数の結果型と同じ型でなければいけない。

### 分岐: if

`if cond { x } else { y }` は `match cond { true => x, false => y }` と同じ規則に従う。

### 分岐: match

`match cond { p1 => x1, ... }`

- cond とアームのパターン (`pi`) はすべて同じ型でなければいけない。
- アームの本体 (`xi`) はすべて同じ型でなければいけない。これが match の結果の型になる。

### ループ: while

`while cond { x }` は `loop { if cond { x } else { break } }` と同じ規則に従う。

### ループ: loop

`loop { ... }`

- loop の結果型は、すべての break の引数と同じ型でなければいけない。
    - はじめ、loop の結果型はフレッシュな型変数 T である。
    - このループに対応する break が1つ出現するたび、その引数の型を T に単一化する。
