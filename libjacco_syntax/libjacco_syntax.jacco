// ジャッコ言語の構文的操作を扱うライブラリ

extern fn memcpy(dest: *mut (), src: *(), size: usize) -> *mut ();

// -----------------------------------------------
// プロセス管理
// -----------------------------------------------

extern fn abort() -> !;

fn panic(s: *c8) -> ! {
    eprint_s("[ERROR] ");
    eprint_s(s);
    eprint_s("\n");
    abort()
}

// -----------------------------------------------
// メモリ管理
// -----------------------------------------------

extern fn malloc(size: usize) -> *mut ();
extern fn realloc(ptr: *mut (), new_size: usize) -> *mut ();
extern fn free(ptr: *mut ());

// FIXME: 実装
struct Heap {}

fn heap_new() -> Heap {
    Heap {}
}

fn heap_drop(_heap: Heap) {}

/// `alignment * count` バイトのメモリを動的確保する。
///
/// 返されるポインタは NULL ではなく、`alignment` の倍数である。
/// 書き込まれている値は未定義。
fn heap_alloc(_heap: *mut Heap, alignment: usize, count: usize) -> *mut ()
    // ensures(p) p != 0 && (alignment != 0 && count != 0 --> p % alignment == 0)
{
    // 0 バイトの確保は malloc に要求しない。
    if (alignment | count) == 0_usize {
        return 1 as *mut ();
    }

    // 巨大なメモリの確保はエラーで落とす。
    if 1_000_000_000_usize / alignment <= count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] malloc(", (alignment * count) as i32, ")\n");
    let ptr = malloc(alignment * count);
    if ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    ptr
}

fn heap_realloc(_heap: *mut Heap, old_ptr: *mut (), alignment: usize, new_count: usize) -> *mut () {
    if (alignment | new_count) == 0_usize {
        return 1 as *mut ();
    }

    if 1_000_000_000_usize / alignment <= new_count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] realloc(", (alignment * new_count) as i32, ")\n");
    let new_ptr = realloc(old_ptr, alignment * new_count);
    if new_ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    new_ptr
}

fn heap_dealloc(_heap: *mut Heap, _ptr: *mut ()) {}

fn global_heap_init() {}

fn global_heap_deinit() {}

fn global_heap() -> *mut Heap {
    1 as *mut Heap
}

// -----------------------------------------------
// 入出力
// -----------------------------------------------

extern fn eprint_s(value: *c8);
extern fn eprint_t(value: *c8, len: usize);
extern fn eprint_d(value: i32);

fn eprint_sds(s1: *c8, d2: i32, s3: *c8) {
    eprint_s(s1);
    eprint_d(d2);
    eprint_s(s3);
}

// -----------------------------------------------
// テストフレームワーク
// -----------------------------------------------

struct TestTools {
    pass_count: usize,
    fail_count: usize,
}

fn test_tools_new() -> TestTools {
    TestTools {
        pass_count: 0_usize,
        fail_count: 0_usize,
    }
}

fn test_tools_finish(tt: TestTools) -> i32 {
    let total_count = tt.pass_count + tt.fail_count;

    eprint_sds("[TRACE] 表明数 ", total_count as i32, " / ");
    eprint_sds("成功 ", tt.pass_count as i32, " / ");
    eprint_sds("失敗 ", tt.fail_count as i32, "\n");

    if tt.fail_count > 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 一部のテストが失敗しています。\n");
        1
    } else if tt.pass_count == 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 表明がありません。\n");
        1
    } else {
        // 文字色: シアン
        eprint_s("[\x1B[36mINFO]\x1B[0m OK\n");
        0
    }
}

/// 表明が通ったときに呼ばれる。
fn assert_pass(tt: *mut TestTools) {
    (*tt).pass_count += 1_usize;
}

/// 表明が落ちたときに呼ばれる。
fn assert_fail(tt: *mut TestTools) {
    (*tt).fail_count += 1_usize;

    let total_count = (*tt).pass_count + (*tt).fail_count;

    // 文字色: イエロー
    eprint_sds("[\x1B[33mERROR\x1B[0m] 表明エラー #", total_count as i32, "\n");
}

fn assert_that(tt: *mut TestTools, cond: bool, message: *c8) {
    if cond {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        eprint_s("    ");
        eprint_s(message);
        eprint_s("\n");
    }
}

fn assert_eq_i32(tt: *mut TestTools, actual: i32, expected: i32) {
    if actual == expected {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        // 文字色: シアン
        eprint_sds("    期待された結果 \x1B[36m", expected, "\x1B[0m\n");
        // 文字色: イエロー
        eprint_sds("    実際に得た結果 \x1B[33m", actual, "\x1B[0m\n");
    }
}

fn assert_eq_usize(tt: *mut TestTools, actual: usize, expected: usize) {
    assert_eq_i32(tt, actual as i32, expected as i32);
}

// -----------------------------------------------
// 数値ライブラリ
// -----------------------------------------------

fn usize_compare(left: usize, right: usize) -> i32 {
    if left == right {
        0
    } else if left < right {
        -1
    } else {
        1
    }
}

fn usize_min(left: usize, right: usize) -> usize {
    if left < right {
        left
    } else {
        right
    }
}

fn usize_max(left: usize, right: usize) -> usize {
    if left > right {
        left
    } else {
        right
    }
}

// -----------------------------------------------
// Str
// -----------------------------------------------

extern fn strlen(str: *c8) -> usize;

/// 文字列の一部への読み取り専用の参照。
///
/// Rust の `&str`、C++ の `std::string_view` に相当。
struct Str {
    ptr: *c8,
    len: usize,
}

fn str_empty() -> Str {
    Str {
        ptr: "",
        len: 0_usize,
    }
}

fn str_from_raw(c_str: *c8) -> Str {
    Str {
        ptr: c_str,
        len: strlen(c_str),
    }
}

fn str_is_empty(s: Str) -> bool {
    s.len == 0_usize
}

fn str_slice_from(s: Str, start: usize) -> Str {
    if start >= s.len {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: s.len - start,
    }
}

fn str_slice(s: Str, start: usize, end: usize) -> Str {
    if end >= s.len {
        end = s.len;
    }

    if start >= end {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: end - start,
    }
}

fn str_compare(s: Str, other: Str) -> i32 {
    let n = usize_min(s.len, other.len);
    let p = s.ptr;
    let q = other.ptr;
    while n >= 1_usize {
        n -= 1_usize;

        if *p != *q {
            // FIXME: *p as i32 が *(p as i32) にパースされてしまう。
            return usize_compare((*p) as usize, (*q) as usize);
        }

        p += 1_usize;
        q += 1_usize;
    }
    usize_compare(s.len, other.len)
}

fn str_tests(tt: *mut TestTools) {
    let empty = str_empty();
    let hello = str_from_raw("hello");
    assert_eq_usize(tt, hello.len, 5_usize);

    assert_that(tt, empty |> str_is_empty(), "\"\" is empty");
    assert_that(tt, !(hello |> str_is_empty()), "\"hello\" is not empty");

    let lo = str_slice_from(hello, 3_usize);
    assert_eq_usize(tt, lo.len, 2_usize);

    assert_eq_i32(tt, str_compare(str_from_raw("a"), str_from_raw("aa")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("aa"), str_from_raw("ab")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("ba"), str_from_raw("a")), 1);
    assert_eq_i32(tt, str_compare(lo, str_from_raw("lo")), 0);

    assert_eq_i32(tt, str_compare(str_slice(hello, 0_usize, 99_usize), hello), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 99_usize, 66_usize), empty), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 1_usize, 4_usize), str_from_raw("ell")), 0);
}

// -----------------------------------------------
// StrBuf
// -----------------------------------------------

/// メモリを所有する文字列バッファ。
///
/// Rust の `String`、C++ の `std::string` に相当。
struct StrBuf {
    ptr: *mut c8,
    len: usize,
    cap: usize,
}

/// 空の StrBuf を生成する。(動的確保は発生しない。)
fn str_buf_empty() -> StrBuf {
    StrBuf {
        ptr: "" as *mut c8,
        len: 0_usize,
        cap: 0_usize,
    }
}

fn str_buf_new_with_cap(cap: usize) -> StrBuf {
    if cap == 0_usize {
        return str_buf_empty();
    }

    StrBuf {
        ptr: heap_alloc(global_heap(), 1_usize, cap) as *mut c8,
        len: 0_usize,
        cap: cap,
    }
}

fn str_buf_as_str(buf: *StrBuf) -> Str {
    Str {
        ptr: (*buf).ptr,
        len: (*buf).len,
    }
}

fn str_buf_len(buf: *StrBuf) -> usize {
    (*buf).len
}

fn str_buf_grow(buf: *mut StrBuf, new_size: usize) {
    if new_size <= (*buf).cap {
        return;
    }

    if (*buf).cap == 0_usize {
        // ptr がヒープを指していないので、realloc できない。
        (*buf).ptr = heap_alloc(global_heap(), 1_usize, new_size) as *mut c8;
    } else {
        // 再確保の回数を抑えるため、バッファサイズは指数的に増やす。
        new_size = usize_max(new_size, (*buf).cap * 2_usize);

        (*buf).ptr = heap_realloc(global_heap(), (*buf).ptr as *mut (), 1_usize, new_size) as *mut c8;
    }

    (*buf).cap = new_size;
}

fn str_buf_push_c8(buf: *mut StrBuf, c: c8) {
    str_buf_grow(buf, (*buf).len + 1_usize);

    (*buf).ptr[(*buf).len] = c;
    (*buf).len += 1_usize;
}

fn str_buf_push_str(buf: *mut StrBuf, other: Str) {
    str_buf_grow(buf, (*buf).len + other.len);

    memcpy(((*buf).ptr + (*buf).len) as *mut (), other.ptr as *(), other.len);
    (*buf).len += other.len;
}

fn str_buf_tests(tt: *mut TestTools)  {
    let s = str_buf_empty();
    // s == ""
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_empty()), 0);

    str_buf_push_c8(&mut s, 'a');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("a")), 0);

    str_buf_push_c8(&mut s, 'b');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("ab")), 0);

    str_buf_push_str(&mut s, str_from_raw("cd"));
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("abcd")), 0);
}

fn eprint_sts(s1: *c8, t2: Str, s3: *c8) {
    eprint_s(s1);
    eprint_t(t2.ptr, t2.len);
    eprint_s(s3);
}

fn assert_eq_str(tt: *mut TestTools, actual: Str, expected: Str) {
    if str_compare(actual, expected) == 0 {
        assert_pass(tt);
    } else {
        assert_fail(tt);
        // 文字色: シアン
        eprint_sts("    期待された結果 '\x1B[36m", expected, "\x1B[0m'\n");
        // 文字色: イエロー
        eprint_sts("    実際に得た結果 '\x1B[33m", actual, "\x1B[0m'\n");
    }
}

// -----------------------------------------------
// 構文
// -----------------------------------------------

/// 構文木のノードやトークンの種類
enum SyntaxKind {
    /// End of file. 入力の末尾
    Eof,
    /// 1つ以上の改行
    NewLines,
    /// 1つ以上の、改行でない空白文字
    Blank,
    /// 数値リテラル
    Number,
    /// 識別子
    Ident,
    /// `_`
    Underscore,
}

fn syntax_kind_name(kind: SyntaxKind) -> Str {
    let name = match kind {
        SyntaxKind::Eof => "EOF",
        SyntaxKind::NewLines => "NEW_LINES",
        SyntaxKind::Blank => "BLANK",
        SyntaxKind::Number => "NUMBER",
        SyntaxKind::Ident => "IDENT",
        SyntaxKind::Underscore =>"UNDERSCORE",
    };
    str_from_raw(name)
}

struct GreenToken {
    kind: SyntaxKind,
    len: u16,
}

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

struct TokenStream {
    text: Str,
    last: usize,
    current: usize,
}

fn token_stream_new(text: Str) -> TokenStream {
    TokenStream {
        text: text,
        last: 0_usize,
        current: 0_usize,
    }
}

fn token_stream_from_raw(text: *c8) -> TokenStream {
    token_stream_new(str_from_raw(text))
}

/// 前回 commit した位置から現在の位置までの文字列へのスライスを取る。
// fn ts_current_str(ts: *TokenStream) -> Str {
//     (*ts).text |> str_slice((*ts).last, (*ts).current)
// }

/// 次の文字を見る。
fn ts_peek(ts: *TokenStream) -> c8 {
    if (*ts).current >= (*ts).text.len {
        return '\0';
    }

    (*ts).text.ptr[(*ts).current]
}

/// 次の1文字を読み進める。
fn ts_bump(ts: *mut TokenStream)
    // requires ts.current < ts.text.len
{
    // FIXME: Unicode 文字を途中で切らない
    (*ts).current += 1_usize;
}

/// 次の文字が c なら読み進める。読み進めたら true
fn ts_eat1(ts: *mut TokenStream, c: c8) -> bool {
    if ts_peek(ts) == c {
        ts_bump(ts);
        true
    } else {
        false
    }
}

fn ts_commit(ts: *mut TokenStream, kind: SyntaxKind) -> GreenToken {
    let len = (*ts).current - (*ts).last;

    (*ts).last = (*ts).current;

    GreenToken {
        kind: kind,
        len: len as u16,
    }
}

fn c8_is_new_line(c: c8) -> bool {
    match c {
        '\r' => true,
        '\n' => true,
        _ => false,
    }
}

fn c8_is_blank(c: c8) -> bool {
    match c {
        ' ' => true,
        '\t' => true,
        _ => false,
    }
}

fn c8_is_digit(c: c8) -> bool {
    '0' <= c && c <= '9'
}

fn c8_is_bit(c: c8) -> bool {
    match c {
        '0' => true,
        '1' => true,
        _ => false,
    }
}

fn c8_is_hexdigit(c: c8) -> bool {
    ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')
}

fn c8_is_alphabetic(c: c8) -> bool {
    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
}

fn c8_is_exponential(c: c8) -> bool {
    match c {
        'e' => true,
        'E' => true,
        'p' => true,
        'P' => true,
        _ => false,
    }
}

fn c8_is_ident(c: c8) -> bool {
    // FIXME: Unicode 文字も識別子として受け付ける
    c8_is_alphabetic(c) || c8_is_digit(c) || c == '_'
}

fn scan_new_lines(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_new_line() {
        ts |> ts_bump();
    }
}

fn scan_blank(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_blank() {
        ts |> ts_bump();
    }
}

fn scan_digits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_digit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_bits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_bit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_hexdigits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_hexdigit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

enum Radix {
    Decimal,
    Binary,
    Hex,
}

fn scan_digits_with_radix(ts: *mut TokenStream, radix: Radix) {
    match radix {
        Radix::Decimal => scan_digits(ts),
        Radix::Binary => scan_bits(ts),
        Radix::Hex => scan_hexdigits(ts),
    }
}

fn scan_number_with_radix(ts: *mut TokenStream, radix: Radix) {
    ts |> scan_digits_with_radix(radix);

    // 小数部
    if ts |> ts_eat1('.') {
        ts |> scan_digits_with_radix(radix);
    }

    // 指数部
    if ts |> ts_peek() |> c8_is_exponential() {
        ts |> ts_bump();

        match ts |> ts_peek() {
            '+' => ts |> ts_bump(),
            '-' => ts |> ts_bump(),
            _ => {}
        }

        ts |> scan_digits_with_radix(radix);
    }

    // 接尾辞
    ts |> scan_ident();
}

fn scan_ident(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_ident() {
        ts |> ts_bump();
    }
}

fn tokenize_new_lines(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_new_lines();
    ts |> ts_commit(SyntaxKind::NewLines)
}

fn tokenize_blank(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_blank();
    ts |> ts_commit(SyntaxKind::Blank)
}

fn tokenize_number_starting_with_zero(ts: *mut TokenStream) -> GreenToken {
    let radix = match ts |> ts_peek() {
        'b' => Radix::Binary,
        'B' => Radix::Binary,
        'x' => Radix::Hex,
        'X' => Radix::Hex,
        _ => Radix::Decimal,
    };

    if radix != Radix::Decimal {
        ts |> ts_bump(); // [bBxX]
    }

    ts |> scan_number_with_radix(radix);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_decimal(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_number_with_radix(Radix::Decimal);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_ident_starting_with_underscore(ts: *mut TokenStream) -> GreenToken {
    if !(ts |> ts_peek() |> c8_is_ident() ){
        return ts |> ts_commit(SyntaxKind::Underscore);
    }

    ts |> scan_ident();
    ts |> ts_commit(SyntaxKind::Ident)
}

fn tokenize_ident(ts: *mut TokenStream) -> GreenToken {
    scan_ident(ts);
    ts |> ts_commit(SyntaxKind::Ident)
}

fn token_stream_next(ts: *mut TokenStream) -> GreenToken {
    match ts |> ts_peek() {
        '\0' => ts |> ts_commit(SyntaxKind::Eof),
        // FIXME: OR パターン
        '\r' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        '\n' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        ' ' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '\t' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '0' => {
            ts |> ts_bump();
            ts |> tokenize_number_starting_with_zero()
        },
        '_' => {
            ts |> ts_bump();
            ts |> tokenize_ident_starting_with_underscore()
        },
        c => {
            if c8_is_digit(c) {
                ts |> ts_bump();
                ts |> tokenize_decimal()
            } else if c8_is_ident(c) {
                ts |> tokenize_ident()
            } else {
                // FIXME: else の後ろに書くと生成後の C コードにおいて変数 c が未定義参照になってしまう
                eprint_sds("[ERROR] unknown char ", c as i32, "\n");
                // FIXME: abort の結果を返すと void 型の変数が生成されてしまう
                abort();
                ts |> ts_commit(SyntaxKind::Eof)
            }
        }
    }
}

fn tokenize_dump(s: *c8) -> StrBuf {
    let ts = token_stream_from_raw(s);
    let i = 0;
    let buf = str_buf_empty();

    loop {
        let token = token_stream_next(&mut ts);
        if token.kind == SyntaxKind::Eof {
            break;
        }

        if i != 0 {
            str_buf_push_str(&mut buf, str_from_raw(", "));
        }

        str_buf_push_str(&mut buf, syntax_kind_name(token.kind));
        i += 1;

        if i >= 10_000_000 {
            panic("字句解析が EOF に到達しないようです");
        }
    }

    buf
}

fn tokenize_tests(tt: *mut TestTools) {
    let ts = token_stream_from_raw(" \t");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Blank, "expect blank");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");

    let buf = tokenize_dump("  \r\n\r\n  \n");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("BLANK, NEW_LINES, BLANK, NEW_LINES"));

    let buf = tokenize_dump("1_000_000_009_i64    6.02e-23_f64    1.8p19_usize");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("NUMBER, BLANK, NUMBER, BLANK, NUMBER"));

    let buf = tokenize_dump("_0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("IDENT"));

    let buf = tokenize_dump("_ __");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("UNDERSCORE, BLANK, IDENT"));
}

// -----------------------------------------------
// エントリポイント
// -----------------------------------------------

/// テストを実行して、結果コードを返す。
pub fn libjacco_syntax_tests() -> i32 {
    global_heap_init();

    let tt = test_tools_new();
    eprint_s("[TRACE] テストの実行を開始します。\n")

    // FIXME: ブロック文が使えないので if true で代用。
    if true {
        let tt = &mut tt;
        assert_eq_i32(tt, 40 + 2, 42);
        // assert_eq_i32(tt, 40 - 2, 42);

        str_tests(tt);
        str_buf_tests(tt);
        tokenize_tests(tt);
    }

    eprint_s("[TRACE] テストの実行が終了しました。\n");
    let exit_code = test_tools_finish(tt);

    global_heap_deinit();
    exit_code
}
