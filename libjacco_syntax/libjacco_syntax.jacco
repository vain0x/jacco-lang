// ジャッコ言語の構文的操作を扱うライブラリ

// -----------------------------------------------
// プロセス管理
// -----------------------------------------------

extern fn abort() -> !;

fn panic(s: *c8) -> ! {
    eprint_s("[ERROR] ");
    eprint_s(s);
    eprint_s("\n");
    abort()
}

// -----------------------------------------------
// 入出力
// -----------------------------------------------

extern fn eprint_s(value: *c8);
extern fn eprint_d(value: i32);

fn eprint_sds(s1: *c8, d2: i32, s3: *c8) {
    eprint_s(s1);
    eprint_d(d2);
    eprint_s(s3);
}

// -----------------------------------------------
// テストフレームワーク
// -----------------------------------------------

struct TestTools {
    pass_count: usize,
    fail_count: usize,
}

fn test_tools_new() -> TestTools {
    TestTools {
        pass_count: 0_usize,
        fail_count: 0_usize,
    }
}

fn test_tools_finish(tt: TestTools) -> i32 {
    let total_count = tt.pass_count + tt.fail_count;

    eprint_sds("[TRACE] 表明数 ", total_count as i32, " / ");
    eprint_sds("成功 ", tt.pass_count as i32, " / ");
    eprint_sds("失敗 ", tt.fail_count as i32, "\n");

    if tt.fail_count > 0_usize {
        // イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 一部のテストが失敗しています。\n");
        1
    } else if tt.pass_count == 0_usize {
        // イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 表明がありません。\n");
        1
    } else {
        // シアン
        eprint_s("[\x1B[36mINFO]\x1B[0m OK\n");
        0
    }
}

fn assert_eq_i32(tt: *mut TestTools, actual: i32, expected: i32) -> bool {
    if actual == expected {
        (*tt).pass_count += 1_usize;
        true
    } else {
        (*tt).fail_count += 1_usize;
        // イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 表明エラー\n");
        // シアン
        eprint_sds("    期待される結果 \x1B[36m", expected, "\x1B[0m\n");
        // イエロー
        eprint_sds("    実際に出た結果 \x1B[33m", actual, "\x1B[0m\n");
        false
    }
}

// -----------------------------------------------
// 数値ライブラリ
// -----------------------------------------------

fn i32_compare(left: i32, right: i32) -> i32 {
    if left == right {
        0
    } else if left < right {
        -1
    } else {
        1
    }
}

fn usize_min(left: usize, right: usize) -> usize {
    if left < right {
        left
    } else {
        right
    }
}

// -----------------------------------------------
// 文字列ライブラリ
// -----------------------------------------------

extern fn strlen(str: *c8) -> usize;

struct Str {
    ptr: *c8,
    len: usize,
}

fn str_new() -> Str {
    Str {
        ptr: "",
        len: 0_usize,
    }
}

fn str_from_raw(c_str: *c8) -> Str {
    Str {
        ptr: c_str,
        len: strlen(c_str),
    }
}

fn str_slice_from(s: Str, start: usize) -> Str {
    if start >= s.len {
        return str_new();
    }

    Str {
        ptr: s.ptr + start,
        len: s.len - start,
    }
}

fn str_compare(s: Str, other: Str) -> i32 {
    let n = (s.len |> usize_min(other.len)) + 1_usize;
    let p = s.ptr;
    let q = other.ptr;
    while n >= 1_usize {
        n -= 1_usize;

        if *p != *q {
            // FIXME: *p as i32 が *(p as i32) にパースされてしまう。
            return i32_compare((*p) as i32, (*q) as i32);
        }

        p += 1_usize;
        q += 1_usize;
    }
    0
}

fn str_tests(tt: *mut TestTools) {
    let hello = str_from_raw("hello");
    assert_eq_i32(tt, hello.len as i32, 5);

    let lo = str_slice_from(hello, 3_usize);
    assert_eq_i32(tt, lo.len as i32, 2);

    assert_eq_i32(tt, str_compare(str_from_raw("a"), str_from_raw("aa")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("aa"), str_from_raw("ab")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("ba"), str_from_raw("a")), 1);
    assert_eq_i32(tt, str_compare(lo, str_from_raw("lo")), 0);
}

// -----------------------------------------------
// 構文
// -----------------------------------------------

/// 構文木のノードやトークンの種類
enum SyntaxKind {
    /// End of file. 入力の末尾
    Eof,
    /// 1つ以上の改行
    NewLines,
    /// 1つ以上の、改行でない空白文字
    Blank,
}

// -----------------------------------------------
// トークン
// -----------------------------------------------

/// Tokenize context. 字句解析の状態
struct Tx {
    text: Str,
    count: usize,
}

fn tx_new(text: Str) -> Tx {
    Tx {
        text: text,
        count: 0_usize,
    }
}

fn tx_next(tx: *Tx) -> c8 {
    if (*tx).text.len == 0_usize {
        return '\0';
    }

    *(*tx).text.ptr
}

fn tx_bump(tx: *mut Tx)
    // requires tx.text.len >= 1
{
    // FIXME: Unicode 文字を途中で切らない
    (*tx).text.ptr += 1_usize;
    (*tx).text.len -= 1_usize;
}

fn tx_commit(tx: *mut Tx, kind: SyntaxKind) {
    // FIXME: トークンリストに追加
    (*tx).count += 1_usize;
}

fn c8_is_new_line(c: c8) -> bool {
    match c {
        '\r' => true,
        '\n' => true,
        _ => false,
    }
}

fn c8_is_blank(c: c8) -> bool {
    match c {
        ' ' => true,
        '\t' => true,
        _ => false,
    }
}

fn tokenize_new_lines_with_cr(tx: *mut Tx) {
    tx |> tx_bump();
    tokenize_new_lines(tx);
}

fn tokenize_new_lines(tx: *mut Tx) {
    while tx |> tx_next() |> c8_is_new_line() {
        tx |> tx_bump();
    }

    tx |> tx_commit(SyntaxKind::NewLines);
}

fn tokenize_blank(tx: *mut Tx) {
    while tx |> tx_next() |> c8_is_blank() {
        tx |> tx_bump();
    }

    tx |> tx_commit(SyntaxKind::Blank);
}

fn tokenize(text: Str) -> usize {
    let tx = tx_new(text);

    loop {
        match &tx |> tx_next() {
            '\0' => break,

            '\r' => tokenize_new_lines_with_cr(&mut tx),
            '\n' => tokenize_new_lines(&mut tx),

            // FIXME: OR パターンは未実装
            ' ' => tokenize_blank(&mut tx),
            '\t' => tokenize_blank(&mut tx),

            c => {
                eprint_sds("unknown char ", c as i32, "\n");
                abort()
            }
        }
    }

    &mut tx |> tx_commit(SyntaxKind::Eof);
    tx.count
}

fn tokenize_raw(s: *c8) -> usize {
    tokenize(str_from_raw(s))
}

fn tokenize_tests(tt: *mut TestTools) {
    assert_eq_i32(tt, tokenize_raw("") as i32, 1);
    assert_eq_i32(tt, tokenize_raw(" \t ") as i32, 2);
    assert_eq_i32(tt, tokenize_raw("\t\t\r\n\t\n") as i32, 5);
}

// -----------------------------------------------
// エントリポイント
// -----------------------------------------------

/// テストを実行して、結果コードを返す。
pub fn libjacco_syntax_tests() -> i32 {
    let tt = test_tools_new();
    eprint_s("[TRACE] テストの実行を開始します。\n")

    // FIXME: ブロック文が使えないので if true で代用。
    if true {
        let tt = &mut tt;
        assert_eq_i32(tt, 40 + 2, 42);
        // assert_eq_i32(tt, 40 - 2, 42);

        str_tests(tt);
        tokenize_tests(tt);
    }

    eprint_s("[TRACE] テストの実行が終了しました。\n");
    test_tools_finish(tt)
}
