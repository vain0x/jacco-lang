// ã‚¸ãƒ£ãƒƒã‚³è¨€èªã®æ§‹æ–‡çš„æ“ä½œã‚’æ‰±ã†ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

extern fn memcpy(dest: *mut (), src: *(), size: usize) -> *mut ();

extern fn strncmp(s: *c8, t: *c8, len: usize) -> i32;

// -----------------------------------------------
// ãƒ—ãƒ­ã‚»ã‚¹ç®¡ç†
// -----------------------------------------------

extern fn abort() -> !;

fn panic(s: *c8) -> ! {
    eprint_s("[ERROR] ");
    eprint_s(s);
    eprint_s("\n");
    abort()
}

// -----------------------------------------------
// ãƒ¡ãƒ¢ãƒªç®¡ç†
// -----------------------------------------------

extern fn malloc(size: usize) -> *mut ();
extern fn realloc(ptr: *mut (), new_size: usize) -> *mut ();
extern fn free(ptr: *mut ());

// FIXME: å®Ÿè£…
struct Heap {}

fn heap_new() -> Heap {
    Heap {}
}

fn heap_drop(_heap: Heap) {}

/// `alignment * count` ãƒã‚¤ãƒˆã®ãƒ¡ãƒ¢ãƒªã‚’å‹•çš„ç¢ºä¿ã™ã‚‹ã€‚
///
/// è¿”ã•ã‚Œã‚‹ãƒã‚¤ãƒ³ã‚¿ã¯ NULL ã§ã¯ãªãã€`alignment` ã®å€æ•°ã§ã‚ã‚‹ã€‚
/// æ›¸ãè¾¼ã¾ã‚Œã¦ã„ã‚‹å€¤ã¯æœªå®šç¾©ã€‚
fn heap_alloc(_heap: *mut Heap, alignment: usize, count: usize) -> *mut ()
    // ensures(p) p != 0 && (alignment != 0 && count != 0 --> p % alignment == 0)
{
    // 0 ãƒã‚¤ãƒˆã®ç¢ºä¿ã¯ malloc ã«è¦æ±‚ã—ãªã„ã€‚
    if (alignment | count) == 0_usize {
        return 1 as *mut ();
    }

    // å·¨å¤§ãªãƒ¡ãƒ¢ãƒªã®ç¢ºä¿ã¯ã‚¨ãƒ©ãƒ¼ã§è½ã¨ã™ã€‚
    if 1_000_000_000_usize / alignment <= count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] malloc(", (alignment * count) as i32, ")\n");
    let ptr = malloc(alignment * count);
    if ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    ptr
}

fn heap_realloc(_heap: *mut Heap, old_ptr: *mut (), alignment: usize, new_count: usize) -> *mut () {
    if (alignment | new_count) == 0_usize {
        return 1 as *mut ();
    }

    if 1_000_000_000_usize / alignment <= new_count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] realloc(", (alignment * new_count) as i32, ")\n");
    let new_ptr = realloc(old_ptr, alignment * new_count);
    if new_ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    new_ptr
}

fn heap_dealloc(_heap: *mut Heap, _ptr: *mut ()) {}

fn global_heap_init() {}

fn global_heap_deinit() {}

fn global_heap() -> *mut Heap {
    1 as *mut Heap
}

// -----------------------------------------------
// å…¥å‡ºåŠ›
// -----------------------------------------------

extern fn eprint_s(value: *c8);
extern fn eprint_t(value: *c8, len: usize);
extern fn eprint_d(value: i32);

fn eprint_sds(s1: *c8, d2: i32, s3: *c8) {
    eprint_s(s1);
    eprint_d(d2);
    eprint_s(s3);
}

// -----------------------------------------------
// ãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
// -----------------------------------------------

struct TestTools {
    pass_count: usize,
    fail_count: usize,
}

fn test_tools_new() -> TestTools {
    TestTools {
        pass_count: 0_usize,
        fail_count: 0_usize,
    }
}

fn test_tools_finish(tt: TestTools) -> i32 {
    let total_count = tt.pass_count + tt.fail_count;

    eprint_sds("[TRACE] è¡¨æ˜æ•° ", total_count as i32, " / ");
    eprint_sds("æˆåŠŸ ", tt.pass_count as i32, " / ");
    eprint_sds("å¤±æ•— ", tt.fail_count as i32, "\n");

    if tt.fail_count > 0_usize {
        // æ–‡å­—è‰²: ã‚¤ã‚¨ãƒ­ãƒ¼
        eprint_s("[\x1B[33mERROR\x1B[0m] ä¸€éƒ¨ã®ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¦ã„ã¾ã™ã€‚\n");
        1
    } else if tt.pass_count == 0_usize {
        // æ–‡å­—è‰²: ã‚¤ã‚¨ãƒ­ãƒ¼
        eprint_s("[\x1B[33mERROR\x1B[0m] è¡¨æ˜ãŒã‚ã‚Šã¾ã›ã‚“ã€‚\n");
        1
    } else {
        // æ–‡å­—è‰²: ã‚·ã‚¢ãƒ³
        eprint_s("[\x1B[36mINFO]\x1B[0m OK\n");
        0
    }
}

/// è¡¨æ˜ãŒé€šã£ãŸã¨ãã«å‘¼ã°ã‚Œã‚‹ã€‚
fn assert_pass(tt: *mut TestTools) {
    (*tt).pass_count += 1_usize;
}

/// è¡¨æ˜ãŒè½ã¡ãŸã¨ãã«å‘¼ã°ã‚Œã‚‹ã€‚
fn assert_fail(tt: *mut TestTools) {
    (*tt).fail_count += 1_usize;

    let total_count = (*tt).pass_count + (*tt).fail_count;

    // æ–‡å­—è‰²: ã‚¤ã‚¨ãƒ­ãƒ¼
    eprint_sds("[\x1B[33mERROR\x1B[0m] è¡¨æ˜ã‚¨ãƒ©ãƒ¼ #", total_count as i32, "\n");
}

fn assert_that(tt: *mut TestTools, cond: bool, message: *c8) {
    if cond {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        eprint_s("    ");
        eprint_s(message);
        eprint_s("\n");
    }
}

fn assert_eq_i32(tt: *mut TestTools, actual: i32, expected: i32) {
    if actual == expected {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        // æ–‡å­—è‰²: ã‚·ã‚¢ãƒ³
        eprint_sds("    æœŸå¾…ã•ã‚ŒãŸçµæœ \x1B[36m", expected, "\x1B[0m\n");
        // æ–‡å­—è‰²: ã‚¤ã‚¨ãƒ­ãƒ¼
        eprint_sds("    å®Ÿéš›ã«å¾—ãŸçµæœ \x1B[33m", actual, "\x1B[0m\n");
    }
}

fn assert_eq_usize(tt: *mut TestTools, actual: usize, expected: usize) {
    assert_eq_i32(tt, actual as i32, expected as i32);
}

// -----------------------------------------------
// æ•°å€¤ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
// -----------------------------------------------

fn usize_compare(left: usize, right: usize) -> i32 {
    if left == right {
        0
    } else if left < right {
        -1
    } else {
        1
    }
}

fn usize_min(left: usize, right: usize) -> usize {
    if left < right {
        left
    } else {
        right
    }
}

fn usize_max(left: usize, right: usize) -> usize {
    if left > right {
        left
    } else {
        right
    }
}

// -----------------------------------------------
// Str
// -----------------------------------------------

extern fn strlen(str: *c8) -> usize;

/// æ–‡å­—åˆ—ã®ä¸€éƒ¨ã¸ã®èª­ã¿å–ã‚Šå°‚ç”¨ã®å‚ç…§ã€‚
///
/// Rust ã® `&str`ã€C++ ã® `std::string_view` ã«ç›¸å½“ã€‚
struct Str {
    ptr: *c8,
    len: usize,
}

fn str_empty() -> Str {
    Str {
        ptr: "",
        len: 0_usize,
    }
}

fn str_from_raw(c_str: *c8) -> Str {
    Str {
        ptr: c_str,
        len: strlen(c_str),
    }
}

fn str_is_empty(s: Str) -> bool {
    s.len == 0_usize
}

fn str_slice_from(s: Str, start: usize) -> Str {
    if start >= s.len {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: s.len - start,
    }
}

fn str_slice(s: Str, start: usize, end: usize) -> Str {
    if end >= s.len {
        end = s.len;
    }

    if start >= end {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: end - start,
    }
}

fn str_compare(s: Str, other: Str) -> i32 {
    let n = usize_min(s.len, other.len);
    let p = s.ptr;
    let q = other.ptr;
    while n >= 1_usize {
        n -= 1_usize;

        if *p != *q {
            // FIXME: *p as i32 ãŒ *(p as i32) ã«ãƒ‘ãƒ¼ã‚¹ã•ã‚Œã¦ã—ã¾ã†ã€‚
            return usize_compare((*p) as usize, (*q) as usize);
        }

        p += 1_usize;
        q += 1_usize;
    }
    usize_compare(s.len, other.len)
}

fn str_equals_raw(s: Str, other: *c8) -> bool {
    str_compare(s, str_from_raw(other)) == 0
}

fn str_prefix_raw(s: Str, prefix: *c8, len: *mut usize) -> bool {
    let prefix_len = strlen(prefix);
    if s.len >= prefix_len && strncmp(s.ptr, prefix, prefix_len) == 0 {
        *len = prefix_len;
        true
    } else {
        false
    }
}

fn str_tests(tt: *mut TestTools) {
    let empty = str_empty();
    let hello = str_from_raw("hello");
    assert_eq_usize(tt, hello.len, 5_usize);

    assert_that(tt, empty |> str_is_empty(), "\"\" is empty");
    assert_that(tt, !(hello |> str_is_empty()), "\"hello\" is not empty");

    let lo = str_slice_from(hello, 3_usize);
    assert_eq_usize(tt, lo.len, 2_usize);

    assert_eq_i32(tt, str_compare(str_from_raw("a"), str_from_raw("aa")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("aa"), str_from_raw("ab")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("ba"), str_from_raw("a")), 1);
    assert_eq_i32(tt, str_compare(lo, str_from_raw("lo")), 0);

    assert_eq_i32(tt, str_compare(str_slice(hello, 0_usize, 99_usize), hello), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 99_usize, 66_usize), empty), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 1_usize, 4_usize), str_from_raw("ell")), 0);
}

// -----------------------------------------------
// StrBuf
// -----------------------------------------------

/// ãƒ¡ãƒ¢ãƒªã‚’æ‰€æœ‰ã™ã‚‹æ–‡å­—åˆ—ãƒãƒƒãƒ•ã‚¡ã€‚
///
/// Rust ã® `String`ã€C++ ã® `std::string` ã«ç›¸å½“ã€‚
struct StrBuf {
    ptr: *mut c8,
    len: usize,
    cap: usize,
}

/// ç©ºã® StrBuf ã‚’ç”Ÿæˆã™ã‚‹ã€‚(å‹•çš„ç¢ºä¿ã¯ç™ºç”Ÿã—ãªã„ã€‚)
fn str_buf_empty() -> StrBuf {
    StrBuf {
        ptr: "" as *mut c8,
        len: 0_usize,
        cap: 0_usize,
    }
}

fn str_buf_new_with_cap(cap: usize) -> StrBuf {
    if cap == 0_usize {
        return str_buf_empty();
    }

    StrBuf {
        ptr: heap_alloc(global_heap(), 1_usize, cap) as *mut c8,
        len: 0_usize,
        cap: cap,
    }
}

fn str_buf_as_str(buf: *StrBuf) -> Str {
    Str {
        ptr: (*buf).ptr,
        len: (*buf).len,
    }
}

fn str_buf_len(buf: *StrBuf) -> usize {
    (*buf).len
}

fn str_buf_grow(buf: *mut StrBuf, new_size: usize) {
    if new_size <= (*buf).cap {
        return;
    }

    if (*buf).cap == 0_usize {
        // ptr ãŒãƒ’ãƒ¼ãƒ—ã‚’æŒ‡ã—ã¦ã„ãªã„ã®ã§ã€realloc ã§ããªã„ã€‚
        (*buf).ptr = heap_alloc(global_heap(), 1_usize, new_size) as *mut c8;
    } else {
        // å†ç¢ºä¿ã®å›æ•°ã‚’æŠ‘ãˆã‚‹ãŸã‚ã€ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã¯æŒ‡æ•°çš„ã«å¢—ã‚„ã™ã€‚
        new_size = usize_max(new_size, (*buf).cap * 2_usize);

        (*buf).ptr = heap_realloc(global_heap(), (*buf).ptr as *mut (), 1_usize, new_size) as *mut c8;
    }

    (*buf).cap = new_size;
}

fn str_buf_push_c8(buf: *mut StrBuf, c: c8) {
    str_buf_grow(buf, (*buf).len + 1_usize);

    (*buf).ptr[(*buf).len] = c;
    (*buf).len += 1_usize;
}

fn str_buf_push_str(buf: *mut StrBuf, other: Str) {
    str_buf_grow(buf, (*buf).len + other.len);

    memcpy(((*buf).ptr + (*buf).len) as *mut (), other.ptr as *(), other.len);
    (*buf).len += other.len;
}

fn str_buf_tests(tt: *mut TestTools)  {
    let s = str_buf_empty();
    // s == ""
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_empty()), 0);

    str_buf_push_c8(&mut s, 'a');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("a")), 0);

    str_buf_push_c8(&mut s, 'b');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("ab")), 0);

    str_buf_push_str(&mut s, str_from_raw("cd"));
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("abcd")), 0);
}

fn eprint_sts(s1: *c8, t2: Str, s3: *c8) {
    eprint_s(s1);
    eprint_t(t2.ptr, t2.len);
    eprint_s(s3);
}

fn assert_eq_str(tt: *mut TestTools, actual: Str, expected: Str) {
    if str_compare(actual, expected) == 0 {
        assert_pass(tt);
    } else {
        assert_fail(tt);
        // æ–‡å­—è‰²: ã‚·ã‚¢ãƒ³
        eprint_sts("    æœŸå¾…ã•ã‚ŒãŸçµæœ '\x1B[36m", expected, "\x1B[0m'\n");
        // æ–‡å­—è‰²: ã‚¤ã‚¨ãƒ­ãƒ¼
        eprint_sts("    å®Ÿéš›ã«å¾—ãŸçµæœ '\x1B[33m", actual, "\x1B[0m'\n");
    }
}

// -----------------------------------------------
// æ§‹æ–‡
// -----------------------------------------------

/// æ§‹æ–‡æœ¨ã®ãƒãƒ¼ãƒ‰ã‚„ãƒˆãƒ¼ã‚¯ãƒ³ã®ç¨®é¡
enum SyntaxKind {
    /// End of file. å…¥åŠ›ã®æœ«å°¾
    Eof,
    /// 1ã¤ä»¥ä¸Šã®æ”¹è¡Œ
    NewLines,
    /// 1ã¤ä»¥ä¸Šã®ã€æ”¹è¡Œã§ãªã„ç©ºç™½æ–‡å­—
    Blank,
    /// ã‚³ãƒ¡ãƒ³ãƒˆ
    Comment,
    /// æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«
    Number,
    /// æ–‡å­—ãƒªãƒ†ãƒ©ãƒ«
    Char,
    /// æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«
    String,
    /// è­˜åˆ¥å­
    Ident,
    /// `_`
    Underscore,

    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰é¡
    As,
    Box,
    Break,
    Case,
    Cl,
    Crate,
    Const,
    Continue,
    Default,
    Defer,
    Do,
    Dyn,
    Else,
    Enum,
    Ensures,
    Export,
    Extern,
    False,
    Fn,
    For,
    From,
    If,
    Impl,
    Import,
    In,
    Inline,
    Let,
    Loop,
    Macro,
    Match,
    Mod,
    Move,
    Mut,
    Of,
    Out,
    Priv,
    Pub,
    Raw,
    Ref,
    Requires,
    Return,
    Safe,
    SelfLower,
    Static,
    Struct,
    Super,
    Then,
    Throw,
    To,
    Trait,
    True,
    Try,
    Type,
    Union,
    Unless,
    Unsafe,
    Until,
    Use,
    Val,
    Void,
    When,
    Where,
    While,
    With,
    Yield,

    // ã‚«ãƒƒã‚³é¡
    /// `(`
    LeftParen,
    /// `)`
    RightParen,
    /// `[`
    LeftBracket,
    /// `]`
    RightBracket,
    /// `{`
    LeftBrace,
    /// `}`
    RightBrace,

    // ç´„ç‰©
    /// `&`
    And,
    /// `&&`
    AndAnd,
    /// `&&=`
    AndAndEqual,
    /// `&=`
    AndEqual,
    /// `!`
    Bang,
    /// `!=`
    BangEqual,
    /// `!==`
    BangEqualEqual,
    /// `:`
    Colon,
    /// `::`
    ColonColon,
    /// `,`
    Comma,
    /// `.`
    Dot,
    /// `..`
    DotDot,
    /// `..=`
    DotDotEqual,
    /// `..<`
    DotDotLeft,
    /// `=`
    Equal,
    /// `==`
    EqualEqual,
    /// `===`
    EqualEqualEqual,
    /// `=>`
    EqualRight,
    /// `#`
    Hash,
    /// `#!`
    HashBang,
    /// `^`
    Hat,
    /// `^=`
    HatEqual,
    /// `<`
    LeftAngle,
    /// `<=`
    LeftEqual,
    /// `<=>`
    LeftEqualRight,
    /// `<<`
    LeftLeft,
    /// `<<=`
    LeftLeftEqual,
    /// `<<<`
    LeftLeftLeft,
    /// `<-`
    LeftMinus,
    /// `<->`
    LeftMinusRight,
    /// `-`
    Minus,
    /// `-=`
    MinusEqual,
    /// `--`
    MinusMinus,
    /// `-->`
    MinusMinusRight,
    /// `->`
    MinusRight,
    /// `%`
    Percent,
    /// `%=`
    PercentEqual,
    /// `|`
    Pipe,
    /// `|=`
    PipeEqual,
    /// `||`
    PipePipe,
    /// `||=`
    PipePipeEqual,
    /// `|>`
    PipeRight,
    /// `+`
    Plus,
    /// `+=`
    PlusEqual,
    /// `++`
    PlusPlus,
    /// `?`
    Question,
    /// `>`
    RightAngle,
    /// `>=`
    RightEqual,
    /// `>>`
    RightRight,
    /// `>>=`
    RightRightEqual,
    /// `>>>`
    RightRightRight,
    /// `;`
    Semi,
    /// `/`
    Slash,
    /// `/=`
    SlashEqual,
    /// `*`
    Star,
    /// `*=`
    StarEqual,
}

fn syntax_kind_is_leading_trivia(kind: SyntaxKind) -> bool {
    match kind {
        SyntaxKind::NewLines => true,
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trailing_trivia(kind: SyntaxKind) -> bool {
    match kind {
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trivia(kind: SyntaxKind) -> bool {
    syntax_kind_is_leading_trivia(kind)
}

fn syntax_kind_name(kind: SyntaxKind) -> Str {
    let name = match kind {
        SyntaxKind::Eof => "EOF",
        SyntaxKind::NewLines => "NEW_LINES",
        SyntaxKind::Blank => "BLANK",
        SyntaxKind::Comment => "COMMENT",
        SyntaxKind::Number => "NUMBER",
        SyntaxKind::Char => "CHAR",
        SyntaxKind::STRING => "STRING",
        SyntaxKind::Ident => "IDENT",
        SyntaxKind::Underscore =>"UNDERSCORE",
        SyntaxKind::As => "AS",
        SyntaxKind::Box => "BOX",
        SyntaxKind::Break => "BREAK",
        SyntaxKind::Case => "CASE",
        SyntaxKind::Cl => "CL",
        SyntaxKind::Crate => "CRATE",
        SyntaxKind::Const => "CONST",
        SyntaxKind::Continue => "CONTINUE",
        SyntaxKind::Default => "DEFAULT",
        SyntaxKind::Defer => "DEFER",
        SyntaxKind::Do => "DO",
        SyntaxKind::Dyn => "DYN",
        SyntaxKind::Else => "ELSE",
        SyntaxKind::Enum => "ENUM",
        SyntaxKind::Ensures => "ENSURES",
        SyntaxKind::Export => "EXPORT",
        SyntaxKind::Extern => "EXTERN",
        SyntaxKind::False => "FALSE",
        SyntaxKind::Fn => "FN",
        SyntaxKind::For => "FOR",
        SyntaxKind::From => "FROM",
        SyntaxKind::If => "IF",
        SyntaxKind::Impl => "IMPL",
        SyntaxKind::Import => "IMPORT",
        SyntaxKind::In => "IN",
        SyntaxKind::Inline => "INLINE",
        SyntaxKind::Let => "LET",
        SyntaxKind::Loop => "LOOP",
        SyntaxKind::Macro => "MACRO",
        SyntaxKind::Match => "MATCH",
        SyntaxKind::Mod => "MOD",
        SyntaxKind::Move => "MOVE",
        SyntaxKind::Mut => "MUT",
        SyntaxKind::Of => "OF",
        SyntaxKind::Out => "OUT",
        SyntaxKind::Priv => "PRIV",
        SyntaxKind::Pub => "PUB",
        SyntaxKind::Raw => "RAW",
        SyntaxKind::Ref => "REF",
        SyntaxKind::Requires => "REQUIRES",
        SyntaxKind::Return => "RETURN",
        SyntaxKind::Safe => "SAFE",
        SyntaxKind::SelfLower => "SELF",
        SyntaxKind::Static => "STATIC",
        SyntaxKind::Struct => "STRUCT",
        SyntaxKind::Super => "SUPER",
        SyntaxKind::Then => "THEN",
        SyntaxKind::Throw => "THROW",
        SyntaxKind::To => "TO",
        SyntaxKind::Trait => "TRAIT",
        SyntaxKind::True => "TRUE",
        SyntaxKind::Try => "TRY",
        SyntaxKind::Type => "TYPE",
        SyntaxKind::Union => "UNION",
        SyntaxKind::Unless => "UNLESS",
        SyntaxKind::Unsafe => "UNSAFE",
        SyntaxKind::Until => "UNTIL",
        SyntaxKind::Use => "USE",
        SyntaxKind::Val => "VAL",
        SyntaxKind::Void => "VOID",
        SyntaxKind::When => "WHEN",
        SyntaxKind::Where => "WHERE",
        SyntaxKind::While => "WHILE",
        SyntaxKind::With => "WITH",
        SyntaxKind::Yield => "YIELD",
        SyntaxKind::LeftParen => "(",
        SyntaxKind::RightParen => ")",
        SyntaxKind::LeftBracket => "[",
        SyntaxKind::RightBracket => "]",
        SyntaxKind::LeftBrace => "{",
        SyntaxKind::RightBrace => "}",
        SyntaxKind::And => "&",
        SyntaxKind::AndAnd => "&&",
        SyntaxKind::AndAndEqual => "&&=",
        SyntaxKind::AndEqual => "&=",
        SyntaxKind::Bang => "!",
        SyntaxKind::BangEqual => "!=",
        SyntaxKind::BangEqualEqual => "!==",
        SyntaxKind::Colon => ":",
        SyntaxKind::ColonColon => "::",
        SyntaxKind::Comma => ",",
        SyntaxKind::Dot => ".",
        SyntaxKind::DotDot => "..",
        SyntaxKind::DotDotEqual => "..=",
        SyntaxKind::DotDotLeft => "..<",
        SyntaxKind::Equal => "=",
        SyntaxKind::EqualEqual => "==",
        SyntaxKind::EqualEqualEqual => "===",
        SyntaxKind::EqualRight => "=>",
        SyntaxKind::Hash => "#",
        SyntaxKind::HashBang => "#!",
        SyntaxKind::Hat => "^",
        SyntaxKind::HatEqual => "^=",
        SyntaxKind::LeftAngle => "<",
        SyntaxKind::LeftEqual => "<=",
        SyntaxKind::LeftEqualRight => "<=>",
        SyntaxKind::LeftLeft => "<<",
        SyntaxKind::LeftLeftEqual => "<<=",
        SyntaxKind::LeftLeftLeft => "<<<",
        SyntaxKind::LeftMinus => "<-",
        SyntaxKind::LeftMinusRight => "<->",
        SyntaxKind::Minus => "-",
        SyntaxKind::MinusEqual => "-=",
        SyntaxKind::MinusMinus => "--",
        SyntaxKind::MinusMinusRight => "-->",
        SyntaxKind::MinusRight => "->",
        SyntaxKind::Percent => "%",
        SyntaxKind::PercentEqual => "%=",
        SyntaxKind::Pipe => "|",
        SyntaxKind::PipeEqual => "|=",
        SyntaxKind::PipePipe => "||",
        SyntaxKind::PipePipeEqual => "||=",
        SyntaxKind::PipeRight => "|>",
        SyntaxKind::Plus => "+",
        SyntaxKind::PlusEqual => "+=",
        SyntaxKind::PlusPlus => "++",
        SyntaxKind::Question => "?",
        SyntaxKind::RightAngle => ">",
        SyntaxKind::RightEqual => ">=",
        SyntaxKind::RightRight => ">>",
        SyntaxKind::RightRightEqual => ">>=",
        SyntaxKind::RightRightRight => ">>>",
        SyntaxKind::Semi => ";",
        SyntaxKind::Slash => "/",
        SyntaxKind::SlashEqual => "/=",
        SyntaxKind::Star => "*",
        SyntaxKind::StarEqual => "*=",
    };
    str_from_raw(name)
}

fn syntax_kind_from_ident(s: Str) -> SyntaxKind
    // requires s.len >= 1
{
    match *s.ptr {
        '_' => {
            if str_equals_raw(s, "_") {
                return SyntaxKind::Underscore;
            }
        },
        'a' => {
            if str_equals_raw(s, "as") {
                return SyntaxKind::As;
            }
        },
        'b' => {
            if str_equals_raw(s, "box") {
                return SyntaxKind::Box;
            }

            if str_equals_raw(s, "break") {
                return SyntaxKind::Break;
            }
        },
        'c' => {
            if str_equals_raw(s, "case") {
                return SyntaxKind::Case;
            }

            if str_equals_raw(s, "cl") {
                return SyntaxKind::Cl;
            }

            if str_equals_raw(s, "crate") {
                return SyntaxKind::Crate;
            }

            if str_equals_raw(s, "const") {
                return SyntaxKind::Const;
            }

            if str_equals_raw(s, "continue") {
                return SyntaxKind::Continue;
            }
        },
        'd' => {
            if str_equals_raw(s, "default") {
                return SyntaxKind::Default;
            }

            if str_equals_raw(s, "defer") {
                return SyntaxKind::Defer;
            }

            if str_equals_raw(s, "do") {
                return SyntaxKind::Do;
            }

            if str_equals_raw(s, "dyn") {
                return SyntaxKind::Dyn;
            }
        },
        'e' => {
            if str_equals_raw(s, "else") {
                return SyntaxKind::Else;
            }

            if str_equals_raw(s, "enum") {
                return SyntaxKind::Enum;
            }

            if str_equals_raw(s, "ensures") {
                return SyntaxKind::Ensures;
            }

            if str_equals_raw(s, "export") {
                return SyntaxKind::Export;
            }

            if str_equals_raw(s, "extern") {
                return SyntaxKind::Extern;
            }
        },
        'f' => {
            if str_equals_raw(s, "false") {
                return SyntaxKind::False;
            }

            if str_equals_raw(s, "fn") {
                return SyntaxKind::Fn;
            }

            if str_equals_raw(s, "for") {
                return SyntaxKind::For;
            }

            if str_equals_raw(s, "from") {
                return SyntaxKind::From;
            }
        },
        'i' => {
            if str_equals_raw(s, "if") {
                return SyntaxKind::If;
            }

            if str_equals_raw(s, "impl") {
                return SyntaxKind::Impl;
            }

            if str_equals_raw(s, "import") {
                return SyntaxKind::Import;
            }

            if str_equals_raw(s, "in") {
                return SyntaxKind::In;
            }

            if str_equals_raw(s, "inline") {
                return SyntaxKind::Inline;
            }
        },
        'l' => {
            if str_equals_raw(s, "let") {
                return SyntaxKind::Let;
            }

            if str_equals_raw(s, "loop") {
                return SyntaxKind::Loop;
            }
        },
        'm' => {
            if str_equals_raw(s, "macro") {
                return SyntaxKind::Macro;
            }

            if str_equals_raw(s, "match") {
                return SyntaxKind::Match;
            }

            if str_equals_raw(s, "mod") {
                return SyntaxKind::Mod;
            }

            if str_equals_raw(s, "move") {
                return SyntaxKind::Move;
            }

            if str_equals_raw(s, "mut") {
                return SyntaxKind::Mut;
            }
        },
        'o' => {
            if str_equals_raw(s, "of") {
                return SyntaxKind::Of;
            }

            if str_equals_raw(s, "out") {
                return SyntaxKind::Out;
            }
        },
        'p' => {
            if str_equals_raw(s, "priv") {
                return SyntaxKind::Priv;
            }

            if str_equals_raw(s, "pub") {
                return SyntaxKind::Pub;
            }
        },
        'r' => {
            if str_equals_raw(s, "raw") {
                return SyntaxKind::Raw;
            }

            if str_equals_raw(s, "ref") {
                return SyntaxKind::Ref;
            }

            if str_equals_raw(s, "requires") {
                return SyntaxKind::Requires;
            }

            if str_equals_raw(s, "return") {
                return SyntaxKind::Return;
            }
        },
        's' => {
            if str_equals_raw(s, "safe") {
                return SyntaxKind::Safe;
            }

            if str_equals_raw(s, "self") {
                return SyntaxKind::SelfLower;
            }

            if str_equals_raw(s, "static") {
                return SyntaxKind::Static;
            }

            if str_equals_raw(s, "struct") {
                return SyntaxKind::Struct;
            }

            if str_equals_raw(s, "super") {
                return SyntaxKind::Super;
            }
        },
        't' => {
            if str_equals_raw(s, "then") {
                return SyntaxKind::Then;
            }

            if str_equals_raw(s, "throw") {
                return SyntaxKind::Throw;
            }

            if str_equals_raw(s, "to") {
                return SyntaxKind::To;
            }

            if str_equals_raw(s, "trait") {
                return SyntaxKind::Trait;
            }

            if str_equals_raw(s, "true") {
                return SyntaxKind::True;
            }

            if str_equals_raw(s, "try") {
                return SyntaxKind::Try;
            }

            if str_equals_raw(s, "type") {
                return SyntaxKind::Type;
            }
        },
        'u' => {
            if str_equals_raw(s, "union") {
                return SyntaxKind::Union;
            }

            if str_equals_raw(s, "unless") {
                return SyntaxKind::Unless;
            }

            if str_equals_raw(s, "unsafe") {
                return SyntaxKind::Unsafe;
            }

            if str_equals_raw(s, "until") {
                return SyntaxKind::Until;
            }

            if str_equals_raw(s, "use") {
                return SyntaxKind::Use;
            }
        },
        'v' => {
            if str_equals_raw(s, "val") {
                return SyntaxKind::Val;
            }

            if str_equals_raw(s, "void") {
                return SyntaxKind::Void;
            }
        },
        'w' => {
            if str_equals_raw(s, "when") {
                return SyntaxKind::When;
            }

            if str_equals_raw(s, "where") {
                return SyntaxKind::Where;
            }

            if str_equals_raw(s, "while") {
                return SyntaxKind::While;
            }

            if str_equals_raw(s, "with") {
                return SyntaxKind::With;
            }
        },
        'y' => {
            if str_equals_raw(s, "yield") {
                return SyntaxKind::Yield;
            }
        },
        _ => {},
    }

    SyntaxKind::Ident
}

fn syntax_kind_parse_and_pun(s: Str, len: *mut usize) -> SyntaxKind
    // requires *s.ptr == '&'
{
    if s |> str_prefix_raw("&=", len) {
        return SyntaxKind::AndEqual;
    }

    if s |> str_prefix_raw("&&=", len) {
        return SyntaxKind::AndAndEqual;
    }

    if s |> str_prefix_raw("&&", len) {
        return SyntaxKind::AndAnd;
    }

    *len = 1_usize;
    SyntaxKind::And
}

fn syntax_kind_parse_bang_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("!==", len) {
        return SyntaxKind::BangEqualEqual;
    }

    if s |> str_prefix_raw("!=", len) {
        return SyntaxKind::BangEqual;
    }

    *len = 1_usize;
    SyntaxKind::Bang
}

fn syntax_kind_parse_colon_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("::", len) {
        return SyntaxKind::ColonColon;
    }

    *len = 1_usize;
    SyntaxKind::Colon
}

fn syntax_kind_parse_dot_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("..=", len) {
        return SyntaxKind::DotDotEqual;
    }

    if s |> str_prefix_raw("..<", len) {
        return SyntaxKind::DotDotLeft;
    }

    if s |> str_prefix_raw("..", len) {
        return SyntaxKind::DotDot;
    }

    *len = 1_usize;
    SyntaxKind::Dot
}

fn syntax_kind_parse_equal_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("=>", len) {
        return SyntaxKind::EqualRight;
    }

    if s |> str_prefix_raw("===", len) {
        return SyntaxKind::EqualEqualEqual;
    }

    if s |> str_prefix_raw("==", len) {
        return SyntaxKind::EqualEqual;
    }

    *len = 1_usize;
    SyntaxKind::Equal
}

fn syntax_kind_parse_hash_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("#!", len) {
        return SyntaxKind::HashBang;
    }

    *len = 1_usize;
    SyntaxKind::Hash
}

fn syntax_kind_parse_hat_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("^=", len) {
        return SyntaxKind::HatEqual;
    }

    *len = 1_usize;
    SyntaxKind::Hat
}

fn syntax_kind_parse_left_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("<=>", len) {
        return SyntaxKind::LeftEqualRight;
    }

    if s |> str_prefix_raw("<=", len) {
        return SyntaxKind::LeftEqual;
    }

    if s |> str_prefix_raw("<<=", len) {
        return SyntaxKind::LeftLeftEqual;
    }

    if s |> str_prefix_raw("<<<", len) {
        return SyntaxKind::LeftLeftLeft;
    }

    if s |> str_prefix_raw("<<", len) {
        return SyntaxKind::LeftLeft;
    }

    if s |> str_prefix_raw("<->", len) {
        return SyntaxKind::LeftMinusRight;
    }

    if s |> str_prefix_raw("<-", len) {
        return SyntaxKind::LeftMinus;
    }

    *len = 1_usize;
    SyntaxKind::LeftAngle
}

fn syntax_kind_parse_minus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("->", len) {
        return SyntaxKind::MinusRight;
    }

    if s |> str_prefix_raw("-=", len) {
        return SyntaxKind::MinusEqual;
    }

    if s |> str_prefix_raw("-->", len) {
        return SyntaxKind::MinusMinusRight;
    }

    if s |> str_prefix_raw("--", len) {
        return SyntaxKind::MinusMinus;
    }

    *len = 1_usize;
    SyntaxKind::Minus
}

fn syntax_kind_parse_percent_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("%=", len) {
        return SyntaxKind::PercentEqual;
    }

    *len = 1_usize;
    SyntaxKind::Percent
}

fn syntax_kind_parse_pipe_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("||=", len) {
        return SyntaxKind::PipePipeEqual;
    }

    if s |> str_prefix_raw("||", len) {
        return SyntaxKind::PipePipe;
    }

    if s |> str_prefix_raw("|>", len) {
        return SyntaxKind::PipeRight;
    }

    if s |> str_prefix_raw("|=", len) {
        return SyntaxKind::PipeEqual;
    }

    *len = 1_usize;
    SyntaxKind::Pipe
}

fn syntax_kind_parse_plus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("+=", len) {
        return SyntaxKind::PlusEqual;
    }

    if s |> str_prefix_raw("++", len) {
        return SyntaxKind::PlusPlus;
    }

    *len = 1_usize;
    SyntaxKind::Plus
}

fn syntax_kind_parse_right_angle_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw(">>>", len) {
        return SyntaxKind::RightRightRight;
    }

    if s |> str_prefix_raw(">>=", len) {
        return SyntaxKind::RightRightEqual;
    }

    if s |> str_prefix_raw(">>", len) {
        return SyntaxKind::RightRight;
    }

    if s |> str_prefix_raw(">=", len) {
        return SyntaxKind::RightEqual;
    }

    *len = 1_usize;
    SyntaxKind::RightAngle
}

fn syntax_kind_parse_star_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("*=", len) {
        return SyntaxKind::StarEqual;
    }

    *len = 1_usize;
    SyntaxKind::Star
}

struct GreenToken {
    kind: SyntaxKind,
    len: u16,
}

// -----------------------------------------------
// å­—å¥è§£æ
// -----------------------------------------------

struct TokenStream {
    text: Str,
    last: usize,
    current: usize,
}

fn token_stream_new(text: Str) -> TokenStream {
    TokenStream {
        text: text,
        last: 0_usize,
        current: 0_usize,
    }
}

fn token_stream_from_raw(text: *c8) -> TokenStream {
    token_stream_new(str_from_raw(text))
}

/// å‰å› commit ã—ãŸä½ç½®ã‹ã‚‰ç¾åœ¨ã®ä½ç½®ã¾ã§ã®æ–‡å­—åˆ—ã¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–ã‚‹ã€‚
fn ts_current_str(ts: *TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).last, (*ts).current)
}

/// ç¾åœ¨ã®ä½ç½®ã‚ˆã‚Šå¾Œã«ã‚ã‚‹æ–‡å­—åˆ—ã¸ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’å–ã‚‹ã€‚
fn ts_rest_str(ts: *mut TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).current, (*ts).text.len)
}

/// æ¬¡ã®æ–‡å­—ã‚’è¦‹ã‚‹ã€‚
fn ts_peek(ts: *TokenStream) -> c8 {
    if (*ts).current >= (*ts).text.len {
        return '\0';
    }

    (*ts).text.ptr[(*ts).current]
}

fn ts_bump_many(ts: *mut TokenStream, len: usize)
    // requires ts.current + len <= ts.text.len && ts.current + len is char boundary of ts.text
{
    (*ts).current += len;
}

/// æ¬¡ã®1æ–‡å­—ã‚’èª­ã¿é€²ã‚ã‚‹ã€‚
fn ts_bump(ts: *mut TokenStream)
    // requires ts.current < ts.text.len && ts.current + 1 is char boundary of ts.text
{
    // FIXME: Unicode æ–‡å­—ã‚’é€”ä¸­ã§åˆ‡ã‚‰ãªã„
    (*ts).current += 1_usize;
}

/// æ¬¡ã®æ–‡å­—ãŒ c ãªã‚‰èª­ã¿é€²ã‚ã‚‹ã€‚èª­ã¿é€²ã‚ãŸã‚‰ true
fn ts_eat1(ts: *mut TokenStream, c: c8) -> bool {
    if ts_peek(ts) == c {
        ts_bump(ts);
        true
    } else {
        false
    }
}

fn ts_commit(ts: *mut TokenStream, kind: SyntaxKind) -> GreenToken {
    let len = (*ts).current - (*ts).last;

    (*ts).last = (*ts).current;

    GreenToken {
        kind: kind,
        len: len as u16,
    }
}

fn c8_is_new_line(c: c8) -> bool {
    match c {
        '\r' => true,
        '\n' => true,
        _ => false,
    }
}

fn c8_is_blank(c: c8) -> bool {
    match c {
        ' ' => true,
        '\t' => true,
        _ => false,
    }
}

fn c8_is_digit(c: c8) -> bool {
    '0' <= c && c <= '9'
}

fn c8_is_bit(c: c8) -> bool {
    match c {
        '0' => true,
        '1' => true,
        _ => false,
    }
}

fn c8_is_hexdigit(c: c8) -> bool {
    ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')
}

fn c8_is_alphabetic(c: c8) -> bool {
    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
}

fn c8_is_exponential(c: c8) -> bool {
    match c {
        'e' => true,
        'E' => true,
        'p' => true,
        'P' => true,
        _ => false,
    }
}

fn c8_is_ident(c: c8) -> bool {
    // FIXME: Unicode æ–‡å­—ã‚‚è­˜åˆ¥å­ã¨ã—ã¦å—ã‘ä»˜ã‘ã‚‹
    c8_is_alphabetic(c) || c8_is_digit(c) || c == '_'
}

fn scan_new_lines(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_new_line() {
        ts |> ts_bump();
    }
}

fn scan_blank(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_blank() {
        ts |> ts_bump();
    }
}

fn scan_digits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_digit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_bits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_bit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_hexdigits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_hexdigit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

enum Radix {
    Decimal,
    Binary,
    Hex,
}

fn scan_digits_with_radix(ts: *mut TokenStream, radix: Radix) {
    match radix {
        Radix::Decimal => scan_digits(ts),
        Radix::Binary => scan_bits(ts),
        Radix::Hex => scan_hexdigits(ts),
    }
}

fn scan_number_with_radix(ts: *mut TokenStream, radix: Radix) {
    ts |> scan_digits_with_radix(radix);

    // å°æ•°éƒ¨
    if ts |> ts_eat1('.') {
        ts |> scan_digits_with_radix(radix);
    }

    // æŒ‡æ•°éƒ¨
    if ts |> ts_peek() |> c8_is_exponential() {
        ts |> ts_bump();

        match ts |> ts_peek() {
            '+' => ts |> ts_bump(),
            '-' => ts |> ts_bump(),
            _ => {}
        }

        ts |> scan_digits_with_radix(radix);
    }

    // æ¥å°¾è¾
    ts |> scan_ident();
}

fn scan_string_contents(ts: *mut TokenStream, quote: c8) {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            '\\' => {
                ts |> ts_bump();
                ts |> ts_bump();
                continue;
            }
            '\'' => {
                if quote == '\'' {
                    break;
                }
            }
            '"' => {
                if quote == '\"' {
                    break;
                }
            }
            _ => {}
        }

        ts |> ts_bump();
    }
}

fn scan_ident(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_ident() {
        ts |> ts_bump();
    }
}

fn tokenize_new_lines(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_new_lines();
    ts |> ts_commit(SyntaxKind::NewLines)
}

fn tokenize_blank(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_blank();
    ts |> ts_commit(SyntaxKind::Blank)
}

fn tokenize_comment_after_slash_slash(ts: *mut TokenStream) -> GreenToken {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            _ => ts |> ts_bump(),
        }
    }

    ts |> ts_commit(SyntaxKind::Comment)
}

fn tokenize_number_starting_with_zero(ts: *mut TokenStream) -> GreenToken {
    let radix = match ts |> ts_peek() {
        'b' => Radix::Binary,
        'B' => Radix::Binary,
        'x' => Radix::Hex,
        'X' => Radix::Hex,
        _ => Radix::Decimal,
    };

    if radix != Radix::Decimal {
        ts |> ts_bump(); // [bBxX]
    }

    ts |> scan_number_with_radix(radix);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_decimal(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_number_with_radix(Radix::Decimal);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_char_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('\'');
    ts |> ts_eat1('\'');
    ts |> ts_commit(SyntaxKind::Char)
}

fn tokenize_string_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('"');
    ts |> ts_eat1('"');
    ts |> ts_commit(SyntaxKind::String)
}

fn tokenize_ident_starting_with_underscore(ts: *mut TokenStream) -> GreenToken {
    if !(ts |> ts_peek() |> c8_is_ident() ){
        return ts |> ts_commit(SyntaxKind::Underscore);
    }

    ts |> scan_ident();
    ts |> ts_commit(SyntaxKind::Ident)
}

fn tokenize_ident(ts: *mut TokenStream) -> GreenToken {
    scan_ident(ts);
    let kind = ts |> ts_current_str() |> syntax_kind_from_ident();
    ts |> ts_commit(kind)
}

fn tokenize_pun(ts: *mut TokenStream, kind: SyntaxKind, len: usize) -> GreenToken {
    ts |> ts_bump_many(len);
    ts |> ts_commit(kind)
}

fn token_stream_next(ts: *mut TokenStream) -> GreenToken {
    match ts |> ts_peek() {
        '\0' => ts |> ts_commit(SyntaxKind::Eof),
        // FIXME: OR ãƒ‘ã‚¿ãƒ¼ãƒ³
        '\r' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        '\n' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        ' ' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '\t' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '0' => {
            ts |> ts_bump();
            ts |> tokenize_number_starting_with_zero()
        },
        '\'' => {
            ts |> ts_bump();
            ts |> tokenize_char_after_quote()
        },
        '"' => {
            ts |> ts_bump();
            ts |> tokenize_string_after_quote()
        },
        '_' => {
            ts |> ts_bump();
            ts |> tokenize_ident_starting_with_underscore()
        },
        '(' => ts |> tokenize_pun(SyntaxKind::LeftParen, 1_usize),
        ')' => ts |> tokenize_pun(SyntaxKind::RightParen, 1_usize),
        '[' => ts |> tokenize_pun(SyntaxKind::LeftBracket, 1_usize),
        ']' => ts |> tokenize_pun(SyntaxKind::RightBracket, 1_usize),
        '{' => ts |> tokenize_pun(SyntaxKind::LeftBrace, 1_usize),
        '}' => ts |> tokenize_pun(SyntaxKind::RightBrace, 1_usize),
        ',' => ts |> tokenize_pun(SyntaxKind::Comma, 1_usize),
        '?' => ts |> tokenize_pun(SyntaxKind::Question, 1_usize),
        ';' => ts |> tokenize_pun(SyntaxKind::Semi, 1_usize),
        '/' => {
            ts |> ts_bump();
            match ts |> ts_peek() {
                '/' => {
                    ts |> ts_bump();
                    ts |> tokenize_comment_after_slash_slash()
                },
                '=' => {
                    ts |> ts_bump();
                    ts |> ts_commit(SyntaxKind::SlashEqual)
                },
                _ => ts |> ts_commit(SyntaxKind::Slash),
            }
        },
        '&' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_and_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '!' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_bang_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        ':' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_colon_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '.' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_dot_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '=' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_equal_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '#' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hash_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '^' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hat_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '<' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_left_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '-' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_minus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '%' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_percent_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '|' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_pipe_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '+' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_plus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '>' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_right_angle_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '*' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_star_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        c => {
            if c8_is_digit(c) {
                ts |> ts_bump();
                ts |> tokenize_decimal()
            } else if c8_is_ident(c) {
                ts |> tokenize_ident()
            } else {
                // FIXME: else ã®å¾Œã‚ã«æ›¸ãã¨ç”Ÿæˆå¾Œã® C ã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦å¤‰æ•° c ãŒæœªå®šç¾©å‚ç…§ã«ãªã£ã¦ã—ã¾ã†
                eprint_sds("[ERROR] unknown char ", c as i32, "\n");
                // FIXME: abort ã®çµæœã‚’è¿”ã™ã¨ void å‹ã®å¤‰æ•°ãŒç”Ÿæˆã•ã‚Œã¦ã—ã¾ã†
                abort();
                ts |> ts_commit(SyntaxKind::Eof)
            }
        }
    }
}

fn do_tokenize_dump(s: *c8, include_trivia: bool) -> StrBuf {
    let ts = token_stream_from_raw(s);
    let i = 0;
    let buf = str_buf_empty();

    loop {
        let token = token_stream_next(&mut ts);
        if token.kind == SyntaxKind::Eof {
            break;
        }

        if !include_trivia && syntax_kind_is_trivia(token.kind) {
            i += 1;
            continue;
        }

        if i != 0 {
            str_buf_push_str(&mut buf, str_from_raw(", "));
        }

        str_buf_push_str(&mut buf, syntax_kind_name(token.kind));
        i += 1;

        if i >= 10_000_000 {
            panic("å­—å¥è§£æãŒ EOF ã«åˆ°é”ã—ãªã„ã‚ˆã†ã§ã™");
        }
    }

    buf
}

fn tokenize_dump(s: *c8) -> StrBuf {
    do_tokenize_dump(s, true)
}

fn tokenize_dump_without_trivia(s: *c8) -> StrBuf {
    do_tokenize_dump(s, false)
}

fn tokenize_tests(tt: *mut TestTools) {
    let ts = token_stream_from_raw(" \t");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Blank, "expect blank");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");

    let buf = tokenize_dump("  \r\n\r\n  \n");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("BLANK, NEW_LINES, BLANK, NEW_LINES"));

    // ã‚³ãƒ¡ãƒ³ãƒˆ
    let buf = tokenize_dump("// ğŸ§LF:\n// ç”°CRLF:\r\n// EOF:");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("COMMENT, NEW_LINES, COMMENT, NEW_LINES, COMMENT"));

    let buf = tokenize_dump_without_trivia("1_000_000_009_i64    6.02e-23_f64    1.8p19_usize");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("NUMBER, NUMBER, NUMBER"));

    // æ–‡å­—ãƒªãƒ†ãƒ©ãƒ«
    let buf = tokenize_dump_without_trivia("''  'a'  '\\''");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("CHAR, CHAR, CHAR"));

    // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«
    let buf = tokenize_dump_without_trivia("\"\"  \"I'm a string!\"  \"\\\"\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, STRING, STRING"));

    // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ æ”¹è¡Œã‚„ EOF ã§åœæ­¢ã™ã‚‹ã€‚
    let buf = tokenize_dump("\"\n\n\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, NEW_LINES, STRING"));

    let buf = tokenize_dump("_0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("IDENT"));

    let buf = tokenize_dump_without_trivia("_ __");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("UNDERSCORE, IDENT"));

    // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
    let buf = tokenize_dump_without_trivia("as assign in inline self Self SELF");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("AS, IDENT, IN, INLINE, SELF, IDENT, IDENT"));

    // è¨˜å·é¡
    let buf = tokenize_dump_without_trivia("||= || |> |= | >>> >>= >> >= > => === == = <=> <= <<= <<< << <-> <- < += ++ + ^= ^ %= % #! # &= &&= && & /= / *= * } { ] [ ) ( ..= ..< .. . ? !== != ! :: : ; , -> -= --> -- -");
    let expected = "||=, ||, |>, |=, |, >>>, >>=, >>, >=, >, =>, ===, ==, =, <=>, <=, <<=, <<<, <<, <->, <-, <, +=, ++, +, ^=, ^, %=, %, #!, #, &=, &&=, &&, &, /=, /, *=, *, }, {, ], [, ), (, ..=, ..<, .., ., ?, !==, !=, !, ::, :, ;, ,, ->, -=, -->, --, -";
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw(expected));
}

// -----------------------------------------------
// ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
// -----------------------------------------------

/// ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ã€çµæœã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã€‚
pub fn libjacco_syntax_tests() -> i32 {
    global_heap_init();

    let tt = test_tools_new();
    eprint_s("[TRACE] ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œã‚’é–‹å§‹ã—ã¾ã™ã€‚\n")

    // FIXME: ãƒ–ãƒ­ãƒƒã‚¯æ–‡ãŒä½¿ãˆãªã„ã®ã§ if true ã§ä»£ç”¨ã€‚
    if true {
        let tt = &mut tt;
        assert_eq_i32(tt, 40 + 2, 42);
        // assert_eq_i32(tt, 40 - 2, 42);

        str_tests(tt);
        str_buf_tests(tt);
        tokenize_tests(tt);
    }

    eprint_s("[TRACE] ãƒ†ã‚¹ãƒˆã®å®Ÿè¡ŒãŒçµ‚äº†ã—ã¾ã—ãŸã€‚\n");
    let exit_code = test_tools_finish(tt);

    global_heap_deinit();
    exit_code
}
