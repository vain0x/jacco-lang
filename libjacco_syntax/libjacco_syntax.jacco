// ジャッコ言語の構文的操作を扱うライブラリ

extern fn memcpy(dest: *mut (), src: *(), size: usize) -> *mut ();

extern fn strncmp(s: *c8, t: *c8, len: usize) -> i32;

// -----------------------------------------------
// プロセス管理
// -----------------------------------------------

extern fn abort() -> !;

fn panic(s: *c8) -> ! {
    eprint_s("[ERROR] ");
    eprint_s(s);
    eprint_s("\n");
    abort()
}

fn dyn_assert(cond: bool, message: *c8) {
    if !cond {
        eprint_s("[ERROR] 表明違反！\n");
        eprint_s(message);
        eprint_s("\n");
        abort();
    }
}

// -----------------------------------------------
// アラインメント
// -----------------------------------------------

struct Align {
    value: usize,
}

fn align1() -> Align {
    Align {
        value: 1_usize,
    }
}

fn align_from_i32(align: i32) -> Align {
    dyn_assert(align >= 1, "alignment must be >= 1");
    dyn_assert(align & (align - 1) == 0, "alignment must be 2^N");

    Align {
        value: align as usize,
    }
}

// fn is_aligned(align: Align, value: usize) -> usize {
//     let mask = align.value - 1;
//     value & mask == 0
// }

/// アラインメントの倍数に切り上げる。
fn align_ceil(align: Align, value: usize) -> usize {
    let mask = align.value - 1_usize;
    (value + mask) & usize_bitwise_not(mask)
}

/// サイズ 0 のメモリ領域を指す、アラインされたポインタを作る。
fn aligned_ptr(align: Align) -> *mut () {
    align.value as *mut()
}

/// アラインされたバイト単位のサイズ
struct AlignedSize {
    size: usize,
    align: Align,
}

/// 1-byte アラインメントのサイズ
fn aligned_size_of_align1(size: usize) -> AlignedSize {
    AlignedSize {
        size: size,
        align: align1(),
    }
}

fn aligned_size_from_align(align: Align) -> AlignedSize {
    AlignedSize {
        size: align.value,
        align: align,
    }
}

fn aligned_size_by_mul(count: usize, align: Align) -> AlignedSize {
    if 1_000_000_000_usize / align.value < count {
        panic("count too large");
    }

    AlignedSize {
        size: count * align.value,
        align: align,
    }
}

fn aligned_size_by_ceiling(size: usize, align: Align) -> AlignedSize {
    AlignedSize {
        size: align_ceil(align, size),
        align: align,
    }
}

// -----------------------------------------------
// メモリ管理
// -----------------------------------------------

extern fn malloc(size: usize) -> *mut ();
extern fn realloc(ptr: *mut (), new_size: usize) -> *mut ();
extern fn free(ptr: *mut ());

// FIXME: 実装
struct Heap {}

fn heap_new() -> Heap {
    Heap {}
}

fn heap_drop(_heap: Heap) {}

/// メモリを動的確保する。
///
/// 返されるポインタは NULL ではなく、アラインメントされている。
/// 書き込まれている値は未定義。
fn heap_alloc(_heap: *mut Heap, aligned_size: AlignedSize) -> *mut ()
    // ensures(p) p != nullptr && p % aligned_size.align == 0
{
    let align = aligned_size.align;
    let size = aligned_size.size;

    // 0 バイトの確保は malloc に要求しない。
    if size == 0_usize {
        return aligned_ptr(align);
    }

    // 巨大なメモリの確保はエラーで落とす。
    if size > 1_000_000_000_usize {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] malloc(", size as i32, ")\n");
    let ptr = malloc(size);
    if ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    ptr
}

fn heap_realloc(_heap: *mut Heap, old_ptr: *mut (), aligned_size: AlignedSize) -> *mut () {
    let align = aligned_size.align;
    let size = aligned_size.size;

    if size == 0_usize {
        return aligned_ptr(align);
    }

    if size > 1_000_000_000_usize {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] realloc(", size as i32, ")\n");
    let new_ptr = realloc(old_ptr, size);
    if new_ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    new_ptr
}

fn heap_dealloc(_heap: *mut Heap, _ptr: *mut ()) {}

fn global_heap_init() {}

fn global_heap_deinit() {}

fn global_heap() -> *mut Heap {
    1 as *mut Heap
}

// -----------------------------------------------
// 入出力
// -----------------------------------------------

extern fn eprint_s(value: *c8);
extern fn eprint_t(value: *c8, len: usize);
extern fn eprint_d(value: i32);

fn eprint_sds(s1: *c8, d2: i32, s3: *c8) {
    eprint_s(s1);
    eprint_d(d2);
    eprint_s(s3);
}

// -----------------------------------------------
// テストフレームワーク
// -----------------------------------------------

struct TestTools {
    pass_count: usize,
    fail_count: usize,
}

fn test_tools_new() -> TestTools {
    TestTools {
        pass_count: 0_usize,
        fail_count: 0_usize,
    }
}

fn test_tools_finish(tt: TestTools) -> i32 {
    let total_count = tt.pass_count + tt.fail_count;

    eprint_sds("[TRACE] 表明数 ", total_count as i32, " / ");
    eprint_sds("成功 ", tt.pass_count as i32, " / ");
    eprint_sds("失敗 ", tt.fail_count as i32, "\n");

    if tt.fail_count > 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 一部のテストが失敗しています。\n");
        1
    } else if tt.pass_count == 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 表明がありません。\n");
        1
    } else {
        // 文字色: シアン
        eprint_s("[\x1B[36mINFO]\x1B[0m OK\n");
        0
    }
}

/// 表明が通ったときに呼ばれる。
fn assert_pass(tt: *mut TestTools) {
    (*tt).pass_count += 1_usize;
}

/// 表明が落ちたときに呼ばれる。
fn assert_fail(tt: *mut TestTools) {
    (*tt).fail_count += 1_usize;

    let total_count = (*tt).pass_count + (*tt).fail_count;

    // 文字色: イエロー
    eprint_sds("[\x1B[33mERROR\x1B[0m] 表明エラー #", total_count as i32, "\n");
}

fn assert_that(tt: *mut TestTools, cond: bool, message: *c8) {
    if cond {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        eprint_s("    ");
        eprint_s(message);
        eprint_s("\n");
    }
}

fn assert_eq_i32(tt: *mut TestTools, actual: i32, expected: i32) {
    if actual == expected {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        // 文字色: シアン
        eprint_sds("    期待された結果 \x1B[36m", expected, "\x1B[0m\n");
        // 文字色: イエロー
        eprint_sds("    実際に得た結果 \x1B[33m", actual, "\x1B[0m\n");
    }
}

fn assert_eq_usize(tt: *mut TestTools, actual: usize, expected: usize) {
    assert_eq_i32(tt, actual as i32, expected as i32);
}

// -----------------------------------------------
// usize
// -----------------------------------------------

fn usize_compare(left: usize, right: usize) -> i32 {
    if left == right {
        0
    } else if left < right {
        -1
    } else {
        1
    }
}

fn usize_min(left: usize, right: usize) -> usize {
    if left < right {
        left
    } else {
        right
    }
}

fn usize_max(left: usize, right: usize) -> usize {
    if left > right {
        left
    } else {
        right
    }
}

// FIXME: !x が誤ったコードにコンパイルされるバグがある
fn usize_bitwise_not(value: usize) -> usize {
    value ^ ((-1) as usize)
}

// -----------------------------------------------
// UntypedVec
// -----------------------------------------------

/// 型なし動的配列
struct UntypedVec {
    ptr: *mut (),
    /// 使用済みの領域のサイズ (バイト単位、アラインメントの倍数。)
    len: usize,
    /// 確保している領域のサイズ (バイト単位、アラインメントの倍数。)
    cap: usize,
}

/// 空の型なしベクタを作る。
///
/// 単一のインスタンスに対して、`align` 引数は一貫して同じ値を指定すること。
/// 動的確保は行わない。
fn untyped_vec_new(align: Align) -> UntypedVec {
    UntypedVec {
        ptr: aligned_ptr(align),
        len: 0_usize,
        cap: 0_usize,
    }
}

fn untyped_vec_len(vec: *UntypedVec) -> usize {
    (*vec).len
}

fn untyped_vec_get(vec: *UntypedVec, aligned_index: AlignedSize) -> *() {
    ((*vec).ptr as usize + aligned_index.size) as *()
}

/// 使用済みの領域の末尾へのポインタ
fn untyped_vec_end_mut(vec: *mut UntypedVec) -> *mut () {
    (((*vec).ptr as usize) + (*vec).len) as *mut ()
}

/// ベクタのキャパシティを `required_size` バイト以上に拡張する。
/// すでに十分なキャパシティがあるなら、何もしない。
fn untyped_vec_grow(vec: *mut UntypedVec, align: Align, required_size: usize) {
    if required_size <= (*vec).cap {
        return;
    }

    // 再確保の回数を抑えるため、バッファサイズは指数的に増やす。
    required_size = usize_max(required_size, (*vec).cap * 2_usize);

    let new_size = aligned_size_by_ceiling(required_size, align);

    if (*vec).cap == 0_usize {
        // ptr がヒープを指していないので、realloc は使えない。
        (*vec).ptr = heap_alloc(global_heap(), new_size) as *mut ();
    } else {
        (*vec).ptr = heap_realloc(global_heap(), (*vec).ptr, new_size) as *mut ();
    }

    (*vec).cap = new_size.size;
}

/// `data` が指す一定サイズのデータを `vec` の末尾に書き込み、長さを増やす。
fn untyped_vec_push(vec: *mut UntypedVec, data: *(), aligned_size: AlignedSize) {
    if aligned_size.size == 0_usize {
        return;
    }

    untyped_vec_grow(vec, aligned_size.align, (*vec).len + aligned_size.size);

    memcpy(untyped_vec_end_mut(vec), data, aligned_size.size);
    (*vec).len += aligned_size.size;

    dyn_assert((*vec).len <= (*vec).cap, "len can't exceed cap");
}

fn untyped_vec_tests(tt: *mut TestTools) {
    let align4 = align_from_i32(4);
    let numbers = untyped_vec_new(align4);

    let x = 3;
    untyped_vec_push(&mut numbers, (&x) as *(), aligned_size_from_align(align4));
    assert_eq_usize(tt, numbers.len, 4_usize);

    x = 1;
    untyped_vec_push(&mut numbers, (&x) as *(), aligned_size_from_align(align4));
    assert_eq_usize(tt, numbers.len, 8_usize);

    x = 4;
    untyped_vec_push(&mut numbers, (&x) as *(), aligned_size_from_align(align4));
    assert_eq_usize(tt, numbers.len, 12_usize);

    let value = *(untyped_vec_get(&numbers, aligned_size_by_mul(0_usize, align4)) as *i32);
    assert_eq_i32(tt, value, 3);

    let value = *(untyped_vec_get(&numbers, aligned_size_by_mul(1_usize, align4)) as *i32);
    assert_eq_i32(tt, value, 1);

    let value = *(untyped_vec_get(&numbers, aligned_size_by_mul(2_usize, align4)) as *i32);
    assert_eq_i32(tt, value, 4);
}

// -----------------------------------------------
// Str
// -----------------------------------------------

extern fn strlen(str: *c8) -> usize;

/// 文字列の一部への読み取り専用の参照。
///
/// Rust の `&str`、C++ の `std::string_view` に相当。
struct Str {
    ptr: *c8,
    len: usize,
}

fn str_empty() -> Str {
    Str {
        ptr: "",
        len: 0_usize,
    }
}

fn str_from_raw(c_str: *c8) -> Str {
    Str {
        ptr: c_str,
        len: strlen(c_str),
    }
}

fn str_is_empty(s: Str) -> bool {
    s.len == 0_usize
}

fn str_slice_from(s: Str, start: usize) -> Str {
    if start >= s.len {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: s.len - start,
    }
}

fn str_slice(s: Str, start: usize, end: usize) -> Str {
    if end >= s.len {
        end = s.len;
    }

    if start >= end {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: end - start,
    }
}

fn str_compare(s: Str, other: Str) -> i32 {
    let n = usize_min(s.len, other.len);
    let p = s.ptr;
    let q = other.ptr;
    while n >= 1_usize {
        n -= 1_usize;

        if *p != *q {
            // FIXME: *p as i32 が *(p as i32) にパースされてしまう。
            return usize_compare((*p) as usize, (*q) as usize);
        }

        p += 1_usize;
        q += 1_usize;
    }
    usize_compare(s.len, other.len)
}

fn str_equals_raw(s: Str, other: *c8) -> bool {
    str_compare(s, str_from_raw(other)) == 0
}

/// 文字列が `prefix` で始まるか調べる。
/// もしそうなら true を返し、`prefix` の長さを `len` に設定する。
fn str_prefix_raw(s: Str, prefix: *c8, len: *mut usize) -> bool {
    let prefix_len = strlen(prefix);
    if s.len >= prefix_len && strncmp(s.ptr, prefix, prefix_len) == 0 {
        *len = prefix_len;
        true
    } else {
        false
    }
}

fn str_tests(tt: *mut TestTools) {
    let empty = str_empty();
    let hello = str_from_raw("hello");
    assert_eq_usize(tt, hello.len, 5_usize);

    assert_that(tt, empty |> str_is_empty(), "\"\" is empty");
    assert_that(tt, !(hello |> str_is_empty()), "\"hello\" is not empty");

    let lo = str_slice_from(hello, 3_usize);
    assert_eq_usize(tt, lo.len, 2_usize);

    assert_eq_i32(tt, str_compare(str_from_raw("a"), str_from_raw("aa")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("aa"), str_from_raw("ab")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("ba"), str_from_raw("a")), 1);
    assert_eq_i32(tt, str_compare(lo, str_from_raw("lo")), 0);

    assert_eq_i32(tt, str_compare(str_slice(hello, 0_usize, 99_usize), hello), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 99_usize, 66_usize), empty), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 1_usize, 4_usize), str_from_raw("ell")), 0);
}

// -----------------------------------------------
// StrBuf
// -----------------------------------------------

/// メモリを所有する文字列バッファ。
///
/// Rust の `String`、C++ の `std::string` に相当。
struct StrBuf {
    vec: UntypedVec,
}

/// 空の StrBuf を生成する。
///
/// 動的確保は発生しない。
fn str_buf_empty() -> StrBuf {
    StrBuf {
        vec: untyped_vec_new(align1()),
    }
}

fn str_buf_as_str(buf: *StrBuf) -> Str {
    Str {
        ptr: (*buf).vec.ptr as *c8,
        len: (*buf).vec.len,
    }
}

fn str_buf_len(buf: *StrBuf) -> usize {
    (*buf).vec.len
}

fn str_buf_grow(buf: *mut StrBuf, new_size: usize) {
    untyped_vec_grow(&mut (*buf).vec, align1(), new_size);
}

fn str_buf_push_c8(buf: *mut StrBuf, c: c8) {
    untyped_vec_push(&mut (*buf).vec, (&c) as *(), aligned_size_of_align1(1_usize));
}

fn str_buf_push_str(buf: *mut StrBuf, other: Str) {
    untyped_vec_push(&mut (*buf).vec, other.ptr as *(), aligned_size_of_align1(other.len));
}

fn str_buf_tests(tt: *mut TestTools)  {
    let s = str_buf_empty();
    // s == ""
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_empty()), 0);

    str_buf_push_c8(&mut s, 'a');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("a")), 0);

    str_buf_push_c8(&mut s, 'b');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("ab")), 0);

    str_buf_push_str(&mut s, str_from_raw("cd"));
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("abcd")), 0);
}

fn eprint_sts(s1: *c8, t2: Str, s3: *c8) {
    eprint_s(s1);
    eprint_t(t2.ptr, t2.len);
    eprint_s(s3);
}

fn assert_eq_str(tt: *mut TestTools, actual: Str, expected: Str) {
    if str_compare(actual, expected) == 0 {
        assert_pass(tt);
    } else {
        assert_fail(tt);
        // 文字色: シアン
        eprint_sts("    期待された結果 '\x1B[36m", expected, "\x1B[0m'\n");
        // 文字色: イエロー
        eprint_sts("    実際に得た結果 '\x1B[33m", actual, "\x1B[0m'\n");
    }
}

// -----------------------------------------------
// 構文
// -----------------------------------------------

/// 構文木のノードやトークンの種類
enum SyntaxKind {
    /// 不正なトークン。
    /// UTF-8 として解釈できない部分や、コメントや文字列の外側に識別子として使えない Unicode 文字があるときなど。
    BadToken,
    /// End of file. 入力の末尾
    Eof,
    /// 1つ以上の改行
    NewLines,
    /// 1つ以上の、改行でない空白文字
    Blank,
    /// コメント
    Comment,
    /// 数値リテラル
    Number,
    /// 文字リテラル
    Char,
    /// 文字列リテラル
    String,
    /// 識別子
    Ident,
    /// `_`
    Underscore,

    // キーワード類
    As,
    Box,
    Break,
    Case,
    Cl,
    Crate,
    Const,
    Continue,
    Default,
    Defer,
    Do,
    Dyn,
    Else,
    Enum,
    Ensures,
    Export,
    Extern,
    False,
    Fn,
    For,
    From,
    If,
    Impl,
    Import,
    In,
    Inline,
    Let,
    Loop,
    Macro,
    Match,
    Mod,
    Move,
    Mut,
    Of,
    Out,
    Priv,
    Pub,
    Raw,
    Ref,
    Requires,
    Return,
    Safe,
    SelfLower,
    Static,
    Struct,
    Super,
    Then,
    Throw,
    To,
    Trait,
    True,
    Try,
    Type,
    Union,
    Unless,
    Unsafe,
    Until,
    Use,
    Val,
    Void,
    When,
    Where,
    While,
    With,
    Yield,

    // カッコ類
    /// `(`
    LeftParen,
    /// `)`
    RightParen,
    /// `[`
    LeftBracket,
    /// `]`
    RightBracket,
    /// `{`
    LeftBrace,
    /// `}`
    RightBrace,

    // 約物
    /// `&`
    And,
    /// `&&`
    AndAnd,
    /// `&&=`
    AndAndEqual,
    /// `&=`
    AndEqual,
    /// `!`
    Bang,
    /// `!=`
    BangEqual,
    /// `!==`
    BangEqualEqual,
    /// `:`
    Colon,
    /// `::`
    ColonColon,
    /// `,`
    Comma,
    /// `.`
    Dot,
    /// `..`
    DotDot,
    /// `..=`
    DotDotEqual,
    /// `..<`
    DotDotLeft,
    /// `=`
    Equal,
    /// `==`
    EqualEqual,
    /// `===`
    EqualEqualEqual,
    /// `=>`
    EqualRight,
    /// `#`
    Hash,
    /// `#!`
    HashBang,
    /// `^`
    Hat,
    /// `^=`
    HatEqual,
    /// `<`
    LeftAngle,
    /// `<=`
    LeftEqual,
    /// `<=>`
    LeftEqualRight,
    /// `<<`
    LeftLeft,
    /// `<<=`
    LeftLeftEqual,
    /// `<<<`
    LeftLeftLeft,
    /// `<-`
    LeftMinus,
    /// `<->`
    LeftMinusRight,
    /// `-`
    Minus,
    /// `-=`
    MinusEqual,
    /// `--`
    MinusMinus,
    /// `-->`
    MinusMinusRight,
    /// `->`
    MinusRight,
    /// `%`
    Percent,
    /// `%=`
    PercentEqual,
    /// `|`
    Pipe,
    /// `|=`
    PipeEqual,
    /// `||`
    PipePipe,
    /// `||=`
    PipePipeEqual,
    /// `|>`
    PipeRight,
    /// `+`
    Plus,
    /// `+=`
    PlusEqual,
    /// `++`
    PlusPlus,
    /// `?`
    Question,
    /// `>`
    RightAngle,
    /// `>=`
    RightEqual,
    /// `>>`
    RightRight,
    /// `>>=`
    RightRightEqual,
    /// `>>>`
    RightRightRight,
    /// `;`
    Semi,
    /// `/`
    Slash,
    /// `/=`
    SlashEqual,
    /// `*`
    Star,
    /// `*=`
    StarEqual,
}

fn syntax_kind_is_leading_trivia(kind: SyntaxKind) -> bool {
    match kind {
        SyntaxKind::BadToken => true,
        SyntaxKind::NewLines => true,
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trailing_trivia(kind: SyntaxKind) -> bool {
    // 改行は含まない。
    match kind {
        SyntaxKind::BadToken => true,
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trivia(kind: SyntaxKind) -> bool {
    syntax_kind_is_leading_trivia(kind)
}

fn syntax_kind_name(kind: SyntaxKind) -> Str {
    let name = match kind {
        SyntaxKind::BadToken => "BAD_TOKEN",
        SyntaxKind::Eof => "EOF",
        SyntaxKind::NewLines => "NEW_LINES",
        SyntaxKind::Blank => "BLANK",
        SyntaxKind::Comment => "COMMENT",
        SyntaxKind::Number => "NUMBER",
        SyntaxKind::Char => "CHAR",
        SyntaxKind::STRING => "STRING",
        SyntaxKind::Ident => "IDENT",
        SyntaxKind::Underscore =>"UNDERSCORE",
        SyntaxKind::As => "AS",
        SyntaxKind::Box => "BOX",
        SyntaxKind::Break => "BREAK",
        SyntaxKind::Case => "CASE",
        SyntaxKind::Cl => "CL",
        SyntaxKind::Crate => "CRATE",
        SyntaxKind::Const => "CONST",
        SyntaxKind::Continue => "CONTINUE",
        SyntaxKind::Default => "DEFAULT",
        SyntaxKind::Defer => "DEFER",
        SyntaxKind::Do => "DO",
        SyntaxKind::Dyn => "DYN",
        SyntaxKind::Else => "ELSE",
        SyntaxKind::Enum => "ENUM",
        SyntaxKind::Ensures => "ENSURES",
        SyntaxKind::Export => "EXPORT",
        SyntaxKind::Extern => "EXTERN",
        SyntaxKind::False => "FALSE",
        SyntaxKind::Fn => "FN",
        SyntaxKind::For => "FOR",
        SyntaxKind::From => "FROM",
        SyntaxKind::If => "IF",
        SyntaxKind::Impl => "IMPL",
        SyntaxKind::Import => "IMPORT",
        SyntaxKind::In => "IN",
        SyntaxKind::Inline => "INLINE",
        SyntaxKind::Let => "LET",
        SyntaxKind::Loop => "LOOP",
        SyntaxKind::Macro => "MACRO",
        SyntaxKind::Match => "MATCH",
        SyntaxKind::Mod => "MOD",
        SyntaxKind::Move => "MOVE",
        SyntaxKind::Mut => "MUT",
        SyntaxKind::Of => "OF",
        SyntaxKind::Out => "OUT",
        SyntaxKind::Priv => "PRIV",
        SyntaxKind::Pub => "PUB",
        SyntaxKind::Raw => "RAW",
        SyntaxKind::Ref => "REF",
        SyntaxKind::Requires => "REQUIRES",
        SyntaxKind::Return => "RETURN",
        SyntaxKind::Safe => "SAFE",
        SyntaxKind::SelfLower => "SELF",
        SyntaxKind::Static => "STATIC",
        SyntaxKind::Struct => "STRUCT",
        SyntaxKind::Super => "SUPER",
        SyntaxKind::Then => "THEN",
        SyntaxKind::Throw => "THROW",
        SyntaxKind::To => "TO",
        SyntaxKind::Trait => "TRAIT",
        SyntaxKind::True => "TRUE",
        SyntaxKind::Try => "TRY",
        SyntaxKind::Type => "TYPE",
        SyntaxKind::Union => "UNION",
        SyntaxKind::Unless => "UNLESS",
        SyntaxKind::Unsafe => "UNSAFE",
        SyntaxKind::Until => "UNTIL",
        SyntaxKind::Use => "USE",
        SyntaxKind::Val => "VAL",
        SyntaxKind::Void => "VOID",
        SyntaxKind::When => "WHEN",
        SyntaxKind::Where => "WHERE",
        SyntaxKind::While => "WHILE",
        SyntaxKind::With => "WITH",
        SyntaxKind::Yield => "YIELD",
        SyntaxKind::LeftParen => "LEFT_PAREN",
        SyntaxKind::RightParen => "RIGHT_PAREN",
        SyntaxKind::LeftBracket => "LEFT_BRACKET",
        SyntaxKind::RightBracket => "RIGHT_BRACKET",
        SyntaxKind::LeftBrace => "LEFT_BRACE",
        SyntaxKind::RightBrace => "RIGHT_BRACE",
        SyntaxKind::And => "&",
        SyntaxKind::AndAnd => "&&",
        SyntaxKind::AndAndEqual => "&&=",
        SyntaxKind::AndEqual => "&=",
        SyntaxKind::Bang => "!",
        SyntaxKind::BangEqual => "!=",
        SyntaxKind::BangEqualEqual => "!==",
        SyntaxKind::Colon => ":",
        SyntaxKind::ColonColon => "::",
        SyntaxKind::Comma => "COMMA",
        SyntaxKind::Dot => ".",
        SyntaxKind::DotDot => "..",
        SyntaxKind::DotDotEqual => "..=",
        SyntaxKind::DotDotLeft => "..<",
        SyntaxKind::Equal => "=",
        SyntaxKind::EqualEqual => "==",
        SyntaxKind::EqualEqualEqual => "===",
        SyntaxKind::EqualRight => "=>",
        SyntaxKind::Hash => "#",
        SyntaxKind::HashBang => "#!",
        SyntaxKind::Hat => "^",
        SyntaxKind::HatEqual => "^=",
        SyntaxKind::LeftAngle => "<",
        SyntaxKind::LeftEqual => "<=",
        SyntaxKind::LeftEqualRight => "<=>",
        SyntaxKind::LeftLeft => "<<",
        SyntaxKind::LeftLeftEqual => "<<=",
        SyntaxKind::LeftLeftLeft => "<<<",
        SyntaxKind::LeftMinus => "<-",
        SyntaxKind::LeftMinusRight => "<->",
        SyntaxKind::Minus => "-",
        SyntaxKind::MinusEqual => "-=",
        SyntaxKind::MinusMinus => "--",
        SyntaxKind::MinusMinusRight => "-->",
        SyntaxKind::MinusRight => "->",
        SyntaxKind::Percent => "%",
        SyntaxKind::PercentEqual => "%=",
        SyntaxKind::Pipe => "|",
        SyntaxKind::PipeEqual => "|=",
        SyntaxKind::PipePipe => "||",
        SyntaxKind::PipePipeEqual => "||=",
        SyntaxKind::PipeRight => "|>",
        SyntaxKind::Plus => "+",
        SyntaxKind::PlusEqual => "+=",
        SyntaxKind::PlusPlus => "++",
        SyntaxKind::Question => "?",
        SyntaxKind::RightAngle => ">",
        SyntaxKind::RightEqual => ">=",
        SyntaxKind::RightRight => ">>",
        SyntaxKind::RightRightEqual => ">>=",
        SyntaxKind::RightRightRight => ">>>",
        SyntaxKind::Semi => ";",
        SyntaxKind::Slash => "/",
        SyntaxKind::SlashEqual => "/=",
        SyntaxKind::Star => "*",
        SyntaxKind::StarEqual => "*=",
    };
    str_from_raw(name)
}

fn syntax_kind_from_ident(s: Str) -> SyntaxKind
    // requires s.len >= 1
{
    match *s.ptr {
        '_' => {
            if str_equals_raw(s, "_") {
                return SyntaxKind::Underscore;
            }
        },
        'a' => {
            if str_equals_raw(s, "as") {
                return SyntaxKind::As;
            }
        },
        'b' => {
            if str_equals_raw(s, "box") {
                return SyntaxKind::Box;
            }

            if str_equals_raw(s, "break") {
                return SyntaxKind::Break;
            }
        },
        'c' => {
            if str_equals_raw(s, "case") {
                return SyntaxKind::Case;
            }

            if str_equals_raw(s, "cl") {
                return SyntaxKind::Cl;
            }

            if str_equals_raw(s, "crate") {
                return SyntaxKind::Crate;
            }

            if str_equals_raw(s, "const") {
                return SyntaxKind::Const;
            }

            if str_equals_raw(s, "continue") {
                return SyntaxKind::Continue;
            }
        },
        'd' => {
            if str_equals_raw(s, "default") {
                return SyntaxKind::Default;
            }

            if str_equals_raw(s, "defer") {
                return SyntaxKind::Defer;
            }

            if str_equals_raw(s, "do") {
                return SyntaxKind::Do;
            }

            if str_equals_raw(s, "dyn") {
                return SyntaxKind::Dyn;
            }
        },
        'e' => {
            if str_equals_raw(s, "else") {
                return SyntaxKind::Else;
            }

            if str_equals_raw(s, "enum") {
                return SyntaxKind::Enum;
            }

            if str_equals_raw(s, "ensures") {
                return SyntaxKind::Ensures;
            }

            if str_equals_raw(s, "export") {
                return SyntaxKind::Export;
            }

            if str_equals_raw(s, "extern") {
                return SyntaxKind::Extern;
            }
        },
        'f' => {
            if str_equals_raw(s, "false") {
                return SyntaxKind::False;
            }

            if str_equals_raw(s, "fn") {
                return SyntaxKind::Fn;
            }

            if str_equals_raw(s, "for") {
                return SyntaxKind::For;
            }

            if str_equals_raw(s, "from") {
                return SyntaxKind::From;
            }
        },
        'i' => {
            if str_equals_raw(s, "if") {
                return SyntaxKind::If;
            }

            if str_equals_raw(s, "impl") {
                return SyntaxKind::Impl;
            }

            if str_equals_raw(s, "import") {
                return SyntaxKind::Import;
            }

            if str_equals_raw(s, "in") {
                return SyntaxKind::In;
            }

            if str_equals_raw(s, "inline") {
                return SyntaxKind::Inline;
            }
        },
        'l' => {
            if str_equals_raw(s, "let") {
                return SyntaxKind::Let;
            }

            if str_equals_raw(s, "loop") {
                return SyntaxKind::Loop;
            }
        },
        'm' => {
            if str_equals_raw(s, "macro") {
                return SyntaxKind::Macro;
            }

            if str_equals_raw(s, "match") {
                return SyntaxKind::Match;
            }

            if str_equals_raw(s, "mod") {
                return SyntaxKind::Mod;
            }

            if str_equals_raw(s, "move") {
                return SyntaxKind::Move;
            }

            if str_equals_raw(s, "mut") {
                return SyntaxKind::Mut;
            }
        },
        'o' => {
            if str_equals_raw(s, "of") {
                return SyntaxKind::Of;
            }

            if str_equals_raw(s, "out") {
                return SyntaxKind::Out;
            }
        },
        'p' => {
            if str_equals_raw(s, "priv") {
                return SyntaxKind::Priv;
            }

            if str_equals_raw(s, "pub") {
                return SyntaxKind::Pub;
            }
        },
        'r' => {
            if str_equals_raw(s, "raw") {
                return SyntaxKind::Raw;
            }

            if str_equals_raw(s, "ref") {
                return SyntaxKind::Ref;
            }

            if str_equals_raw(s, "requires") {
                return SyntaxKind::Requires;
            }

            if str_equals_raw(s, "return") {
                return SyntaxKind::Return;
            }
        },
        's' => {
            if str_equals_raw(s, "safe") {
                return SyntaxKind::Safe;
            }

            if str_equals_raw(s, "self") {
                return SyntaxKind::SelfLower;
            }

            if str_equals_raw(s, "static") {
                return SyntaxKind::Static;
            }

            if str_equals_raw(s, "struct") {
                return SyntaxKind::Struct;
            }

            if str_equals_raw(s, "super") {
                return SyntaxKind::Super;
            }
        },
        't' => {
            if str_equals_raw(s, "then") {
                return SyntaxKind::Then;
            }

            if str_equals_raw(s, "throw") {
                return SyntaxKind::Throw;
            }

            if str_equals_raw(s, "to") {
                return SyntaxKind::To;
            }

            if str_equals_raw(s, "trait") {
                return SyntaxKind::Trait;
            }

            if str_equals_raw(s, "true") {
                return SyntaxKind::True;
            }

            if str_equals_raw(s, "try") {
                return SyntaxKind::Try;
            }

            if str_equals_raw(s, "type") {
                return SyntaxKind::Type;
            }
        },
        'u' => {
            if str_equals_raw(s, "union") {
                return SyntaxKind::Union;
            }

            if str_equals_raw(s, "unless") {
                return SyntaxKind::Unless;
            }

            if str_equals_raw(s, "unsafe") {
                return SyntaxKind::Unsafe;
            }

            if str_equals_raw(s, "until") {
                return SyntaxKind::Until;
            }

            if str_equals_raw(s, "use") {
                return SyntaxKind::Use;
            }
        },
        'v' => {
            if str_equals_raw(s, "val") {
                return SyntaxKind::Val;
            }

            if str_equals_raw(s, "void") {
                return SyntaxKind::Void;
            }
        },
        'w' => {
            if str_equals_raw(s, "when") {
                return SyntaxKind::When;
            }

            if str_equals_raw(s, "where") {
                return SyntaxKind::Where;
            }

            if str_equals_raw(s, "while") {
                return SyntaxKind::While;
            }

            if str_equals_raw(s, "with") {
                return SyntaxKind::With;
            }
        },
        'y' => {
            if str_equals_raw(s, "yield") {
                return SyntaxKind::Yield;
            }
        },
        _ => {},
    }

    SyntaxKind::Ident
}

fn syntax_kind_parse_and_pun(s: Str, len: *mut usize) -> SyntaxKind
    // requires *s.ptr == '&'
{
    if s |> str_prefix_raw("&=", len) {
        return SyntaxKind::AndEqual;
    }

    if s |> str_prefix_raw("&&=", len) {
        return SyntaxKind::AndAndEqual;
    }

    if s |> str_prefix_raw("&&", len) {
        return SyntaxKind::AndAnd;
    }

    *len = 1_usize;
    SyntaxKind::And
}

fn syntax_kind_parse_bang_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("!==", len) {
        return SyntaxKind::BangEqualEqual;
    }

    if s |> str_prefix_raw("!=", len) {
        return SyntaxKind::BangEqual;
    }

    *len = 1_usize;
    SyntaxKind::Bang
}

fn syntax_kind_parse_colon_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("::", len) {
        return SyntaxKind::ColonColon;
    }

    *len = 1_usize;
    SyntaxKind::Colon
}

fn syntax_kind_parse_dot_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("..=", len) {
        return SyntaxKind::DotDotEqual;
    }

    if s |> str_prefix_raw("..<", len) {
        return SyntaxKind::DotDotLeft;
    }

    if s |> str_prefix_raw("..", len) {
        return SyntaxKind::DotDot;
    }

    *len = 1_usize;
    SyntaxKind::Dot
}

fn syntax_kind_parse_equal_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("=>", len) {
        return SyntaxKind::EqualRight;
    }

    if s |> str_prefix_raw("===", len) {
        return SyntaxKind::EqualEqualEqual;
    }

    if s |> str_prefix_raw("==", len) {
        return SyntaxKind::EqualEqual;
    }

    *len = 1_usize;
    SyntaxKind::Equal
}

fn syntax_kind_parse_hash_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("#!", len) {
        return SyntaxKind::HashBang;
    }

    *len = 1_usize;
    SyntaxKind::Hash
}

fn syntax_kind_parse_hat_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("^=", len) {
        return SyntaxKind::HatEqual;
    }

    *len = 1_usize;
    SyntaxKind::Hat
}

fn syntax_kind_parse_left_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("<=>", len) {
        return SyntaxKind::LeftEqualRight;
    }

    if s |> str_prefix_raw("<=", len) {
        return SyntaxKind::LeftEqual;
    }

    if s |> str_prefix_raw("<<=", len) {
        return SyntaxKind::LeftLeftEqual;
    }

    if s |> str_prefix_raw("<<<", len) {
        return SyntaxKind::LeftLeftLeft;
    }

    if s |> str_prefix_raw("<<", len) {
        return SyntaxKind::LeftLeft;
    }

    if s |> str_prefix_raw("<->", len) {
        return SyntaxKind::LeftMinusRight;
    }

    if s |> str_prefix_raw("<-", len) {
        return SyntaxKind::LeftMinus;
    }

    *len = 1_usize;
    SyntaxKind::LeftAngle
}

fn syntax_kind_parse_minus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("->", len) {
        return SyntaxKind::MinusRight;
    }

    if s |> str_prefix_raw("-=", len) {
        return SyntaxKind::MinusEqual;
    }

    if s |> str_prefix_raw("-->", len) {
        return SyntaxKind::MinusMinusRight;
    }

    if s |> str_prefix_raw("--", len) {
        return SyntaxKind::MinusMinus;
    }

    *len = 1_usize;
    SyntaxKind::Minus
}

fn syntax_kind_parse_percent_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("%=", len) {
        return SyntaxKind::PercentEqual;
    }

    *len = 1_usize;
    SyntaxKind::Percent
}

fn syntax_kind_parse_pipe_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("||=", len) {
        return SyntaxKind::PipePipeEqual;
    }

    if s |> str_prefix_raw("||", len) {
        return SyntaxKind::PipePipe;
    }

    if s |> str_prefix_raw("|>", len) {
        return SyntaxKind::PipeRight;
    }

    if s |> str_prefix_raw("|=", len) {
        return SyntaxKind::PipeEqual;
    }

    *len = 1_usize;
    SyntaxKind::Pipe
}

fn syntax_kind_parse_plus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("+=", len) {
        return SyntaxKind::PlusEqual;
    }

    if s |> str_prefix_raw("++", len) {
        return SyntaxKind::PlusPlus;
    }

    *len = 1_usize;
    SyntaxKind::Plus
}

fn syntax_kind_parse_right_angle_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw(">>>", len) {
        return SyntaxKind::RightRightRight;
    }

    if s |> str_prefix_raw(">>=", len) {
        return SyntaxKind::RightRightEqual;
    }

    if s |> str_prefix_raw(">>", len) {
        return SyntaxKind::RightRight;
    }

    if s |> str_prefix_raw(">=", len) {
        return SyntaxKind::RightEqual;
    }

    *len = 1_usize;
    SyntaxKind::RightAngle
}

fn syntax_kind_parse_star_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("*=", len) {
        return SyntaxKind::StarEqual;
    }

    *len = 1_usize;
    SyntaxKind::Star
}

struct GreenToken {
    kind: SyntaxKind,
    len: u16,
}

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

struct TokenStream {
    text: Str,
    last: usize,
    current: usize,
}

fn token_stream_new(text: Str) -> TokenStream {
    TokenStream {
        text: text,
        last: 0_usize,
        current: 0_usize,
    }
}

fn token_stream_from_raw(text: *c8) -> TokenStream {
    token_stream_new(str_from_raw(text))
}

/// 前回 commit した位置から現在の位置までの文字列へのスライスを取る。
fn ts_current_str(ts: *TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).last, (*ts).current)
}

/// 現在の位置より後にある文字列へのスライスを取る。
fn ts_rest_str(ts: *mut TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).current, (*ts).text.len)
}

/// 次の文字を見る。
fn ts_peek(ts: *TokenStream) -> c8 {
    if (*ts).current >= (*ts).text.len {
        return '\0';
    }

    (*ts).text.ptr[(*ts).current]
}

fn ts_bump_many(ts: *mut TokenStream, len: usize)
    // requires ts.current + len <= ts.text.len && ts.current + len is char boundary of ts.text
{
    (*ts).current += len;
}

/// 次の1文字を読み進める。
fn ts_bump(ts: *mut TokenStream)
    // requires ts.current < ts.text.len && ts.current + 1 is char boundary of ts.text
{
    // FIXME: Unicode 文字を途中で切らない
    (*ts).current += 1_usize;
}

/// 次の文字が c なら読み進める。読み進めたら true
fn ts_eat1(ts: *mut TokenStream, c: c8) -> bool {
    if ts_peek(ts) == c {
        ts_bump(ts);
        true
    } else {
        false
    }
}

fn ts_commit(ts: *mut TokenStream, kind: SyntaxKind) -> GreenToken {
    let len = (*ts).current - (*ts).last;

    (*ts).last = (*ts).current;

    GreenToken {
        kind: kind,
        len: len as u16,
    }
}

fn c8_is_new_line(c: c8) -> bool {
    match c {
        '\r' => true,
        '\n' => true,
        _ => false,
    }
}

fn c8_is_blank(c: c8) -> bool {
    match c {
        ' ' => true,
        '\t' => true,
        _ => false,
    }
}

fn c8_is_digit(c: c8) -> bool {
    '0' <= c && c <= '9'
}

fn c8_is_bit(c: c8) -> bool {
    match c {
        '0' => true,
        '1' => true,
        _ => false,
    }
}

fn c8_is_hexdigit(c: c8) -> bool {
    ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')
}

fn c8_is_alphabetic(c: c8) -> bool {
    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
}

fn c8_is_exponential(c: c8) -> bool {
    match c {
        'e' => true,
        'E' => true,
        'p' => true,
        'P' => true,
        _ => false,
    }
}

fn c8_is_ident(c: c8) -> bool {
    // FIXME: Unicode 文字も識別子として受け付ける
    c8_is_alphabetic(c) || c8_is_digit(c) || c == '_'
}

fn scan_new_lines(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_new_line() {
        ts |> ts_bump();
    }
}

fn scan_blank(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_blank() {
        ts |> ts_bump();
    }
}

fn scan_digits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_digit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_bits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_bit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_hexdigits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_hexdigit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

enum Radix {
    Decimal,
    Binary,
    Hex,
}

fn scan_digits_with_radix(ts: *mut TokenStream, radix: Radix) {
    match radix {
        Radix::Decimal => scan_digits(ts),
        Radix::Binary => scan_bits(ts),
        Radix::Hex => scan_hexdigits(ts),
    }
}

fn scan_number_with_radix(ts: *mut TokenStream, radix: Radix) {
    ts |> scan_digits_with_radix(radix);

    // 小数部
    if ts |> ts_eat1('.') {
        ts |> scan_digits_with_radix(radix);
    }

    // 指数部
    if ts |> ts_peek() |> c8_is_exponential() {
        ts |> ts_bump();

        match ts |> ts_peek() {
            '+' => ts |> ts_bump(),
            '-' => ts |> ts_bump(),
            _ => {}
        }

        ts |> scan_digits_with_radix(radix);
    }

    // 接尾辞
    ts |> scan_ident();
}

fn scan_string_contents(ts: *mut TokenStream, quote: c8) {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            '\\' => {
                ts |> ts_bump();
                ts |> ts_bump();
                continue;
            }
            '\'' => {
                if quote == '\'' {
                    break;
                }
            }
            '"' => {
                if quote == '\"' {
                    break;
                }
            }
            _ => {}
        }

        ts |> ts_bump();
    }
}

fn scan_ident(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_ident() {
        ts |> ts_bump();
    }
}

fn tokenize_new_lines(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_new_lines();
    ts |> ts_commit(SyntaxKind::NewLines)
}

fn tokenize_blank(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_blank();
    ts |> ts_commit(SyntaxKind::Blank)
}

fn tokenize_comment_after_slash_slash(ts: *mut TokenStream) -> GreenToken {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            _ => ts |> ts_bump(),
        }
    }

    ts |> ts_commit(SyntaxKind::Comment)
}

fn tokenize_number_starting_with_zero(ts: *mut TokenStream) -> GreenToken {
    let radix = match ts |> ts_peek() {
        'b' => Radix::Binary,
        'B' => Radix::Binary,
        'x' => Radix::Hex,
        'X' => Radix::Hex,
        _ => Radix::Decimal,
    };

    if radix != Radix::Decimal {
        ts |> ts_bump(); // [bBxX]
    }

    ts |> scan_number_with_radix(radix);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_decimal(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_number_with_radix(Radix::Decimal);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_char_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('\'');
    ts |> ts_eat1('\'');
    ts |> ts_commit(SyntaxKind::Char)
}

fn tokenize_string_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('"');
    ts |> ts_eat1('"');
    ts |> ts_commit(SyntaxKind::String)
}

fn tokenize_ident_starting_with_underscore(ts: *mut TokenStream) -> GreenToken {
    if !(ts |> ts_peek() |> c8_is_ident() ){
        return ts |> ts_commit(SyntaxKind::Underscore);
    }

    ts |> scan_ident();
    ts |> ts_commit(SyntaxKind::Ident)
}

fn tokenize_ident(ts: *mut TokenStream) -> GreenToken {
    scan_ident(ts);
    let kind = ts |> ts_current_str() |> syntax_kind_from_ident();
    ts |> ts_commit(kind)
}

fn tokenize_pun(ts: *mut TokenStream, kind: SyntaxKind, len: usize) -> GreenToken {
    ts |> ts_bump_many(len);
    ts |> ts_commit(kind)
}

fn token_stream_next(ts: *mut TokenStream) -> GreenToken {
    match ts |> ts_peek() {
        '\0' => ts |> ts_commit(SyntaxKind::Eof),
        // FIXME: OR パターン
        '\r' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        '\n' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        ' ' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '\t' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '0' => {
            ts |> ts_bump();
            ts |> tokenize_number_starting_with_zero()
        },
        '\'' => {
            ts |> ts_bump();
            ts |> tokenize_char_after_quote()
        },
        '"' => {
            ts |> ts_bump();
            ts |> tokenize_string_after_quote()
        },
        '_' => {
            ts |> ts_bump();
            ts |> tokenize_ident_starting_with_underscore()
        },
        '(' => ts |> tokenize_pun(SyntaxKind::LeftParen, 1_usize),
        ')' => ts |> tokenize_pun(SyntaxKind::RightParen, 1_usize),
        '[' => ts |> tokenize_pun(SyntaxKind::LeftBracket, 1_usize),
        ']' => ts |> tokenize_pun(SyntaxKind::RightBracket, 1_usize),
        '{' => ts |> tokenize_pun(SyntaxKind::LeftBrace, 1_usize),
        '}' => ts |> tokenize_pun(SyntaxKind::RightBrace, 1_usize),
        ',' => ts |> tokenize_pun(SyntaxKind::Comma, 1_usize),
        '?' => ts |> tokenize_pun(SyntaxKind::Question, 1_usize),
        ';' => ts |> tokenize_pun(SyntaxKind::Semi, 1_usize),
        '/' => {
            ts |> ts_bump();
            match ts |> ts_peek() {
                '/' => {
                    ts |> ts_bump();
                    ts |> tokenize_comment_after_slash_slash()
                },
                '=' => {
                    ts |> ts_bump();
                    ts |> ts_commit(SyntaxKind::SlashEqual)
                },
                _ => ts |> ts_commit(SyntaxKind::Slash),
            }
        },
        '&' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_and_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '!' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_bang_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        ':' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_colon_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '.' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_dot_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '=' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_equal_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '#' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hash_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '^' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hat_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '<' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_left_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '-' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_minus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '%' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_percent_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '|' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_pipe_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '+' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_plus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '>' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_right_angle_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '*' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_star_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        c => {
            // FIXME: early return にすると不正なコードが生成されるバグがある
            if c8_is_digit(c) {
                ts |> ts_bump();
                ts |> tokenize_decimal()
            } else if c8_is_ident(c) {
                ts |> tokenize_ident()
            } else {
                eprint_sds("[WARN] 解釈できない文字 ", c as i32, "\n");

                // FIXME: 不正な文字だけスキップする
                // Unicode 文字境界にハマらないように、とりあえず空白まで飛ばす。
                loop {
                    match ts |> ts_peek() {
                        '\0' => break,
                        '\r' => break,
                        '\n' => break,
                        ' ' => break,
                        '\t' => break,
                        _ => ts |> ts_bump(),
                    }
                }
                ts |> ts_commit(SyntaxKind::BadToken)
            }
        }
    }
}

fn do_tokenize_dump(s: *c8, include_trivia: bool) -> StrBuf {
    let ts = token_stream_from_raw(s);
    let i = 0;
    let buf = str_buf_empty();

    loop {
        let token = token_stream_next(&mut ts);
        if token.kind == SyntaxKind::Eof {
            break;
        }

        if !include_trivia && syntax_kind_is_trivia(token.kind) {
            i += 1;
            continue;
        }

        if i != 0 {
            str_buf_push_str(&mut buf, str_from_raw(", "));
        }

        str_buf_push_str(&mut buf, syntax_kind_name(token.kind));
        i += 1;

        if i >= 10_000_000 {
            panic("字句解析が EOF に到達しないようです");
        }
    }

    buf
}

fn tokenize_dump(s: *c8) -> StrBuf {
    do_tokenize_dump(s, true)
}

fn tokenize_dump_without_trivia(s: *c8) -> StrBuf {
    do_tokenize_dump(s, false)
}

fn tokenize_tests(tt: *mut TestTools) {
    let ts = token_stream_from_raw(" \t");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Blank, "expect blank");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");

    let buf = tokenize_dump("  \r\n\r\n  \n");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("BLANK, NEW_LINES, BLANK, NEW_LINES"));

    // コメント
    let buf = tokenize_dump("// 🐧LF:\n// 田CRLF:\r\n// EOF:");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("COMMENT, NEW_LINES, COMMENT, NEW_LINES, COMMENT"));

    let buf = tokenize_dump_without_trivia("1_000_000_009_i64    6.02e-23_f64    1.8p19_usize");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("NUMBER, NUMBER, NUMBER"));

    // 文字リテラル
    let buf = tokenize_dump_without_trivia("''  'a'  '\\''");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("CHAR, CHAR, CHAR"));

    // 文字列リテラル
    let buf = tokenize_dump_without_trivia("\"\"  \"I'm a string!\"  \"\\\"\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, STRING, STRING"));

    // 文字列リテラルは 改行や EOF で停止する。
    let buf = tokenize_dump("\"\n\n\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, NEW_LINES, STRING"));

    let buf = tokenize_dump("_0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("IDENT"));

    let buf = tokenize_dump_without_trivia("_ __");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("UNDERSCORE, IDENT"));

    // キーワード
    let buf = tokenize_dump_without_trivia("as assign in inline self Self SELF");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("AS, IDENT, IN, INLINE, SELF, IDENT, IDENT"));

    // 記号類
    let buf = tokenize_dump_without_trivia("||= || |> |= | >>> >>= >> >= > => === == = <=> <= <<= <<< << <-> <- < += ++ + ^= ^ %= % #! # &= &&= && & /= / *= * } { ] [ ) ( ..= ..< .. . ? !== != ! :: : ; , -> -= --> -- -");
    let expected = "||=, ||, |>, |=, |, >>>, >>=, >>, >=, >, =>, ===, ==, =, <=>, <=, <<=, <<<, <<, <->, <-, <, +=, ++, +, ^=, ^, %=, %, #!, #, &=, &&=, &&, &, /=, /, *=, *, RIGHT_BRACE, LEFT_BRACE, RIGHT_BRACKET, LEFT_BRACKET, RIGHT_PAREN, LEFT_PAREN, ..=, ..<, .., ., ?, !==, !=, !, ::, :, ;, COMMA, ->, -=, -->, --, -";
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw(expected));

    // 不正な文字
    // 「解釈できない文字 240」という警告が出る。
    let buf = tokenize_dump("let 🐧;");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("LET, BLANK, BAD_TOKEN"));
}

// -----------------------------------------------
// エントリポイント
// -----------------------------------------------

/// テストを実行して、結果コードを返す。
pub fn libjacco_syntax_tests() -> i32 {
    global_heap_init();

    let tt = test_tools_new();
    eprint_s("[TRACE] テストの実行を開始します。\n")

    // FIXME: ブロック文が使えないので if true で代用。
    if true {
        let tt = &mut tt;
        assert_eq_i32(tt, 40 + 2, 42);
        // assert_eq_i32(tt, 40 - 2, 42);

        untyped_vec_tests(tt);
        str_tests(tt);
        str_buf_tests(tt);
        tokenize_tests(tt);
    }

    eprint_s("[TRACE] テストの実行が終了しました。\n");
    let exit_code = test_tools_finish(tt);

    global_heap_deinit();
    exit_code
}
