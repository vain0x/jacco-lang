// ジャッコ言語の構文的操作を扱うライブラリ

extern fn memcpy(dest: *mut (), src: *(), size: usize) -> *mut ();

extern fn strncmp(s: *c8, t: *c8, len: usize) -> i32;

// -----------------------------------------------
// プロセス管理
// -----------------------------------------------

extern fn abort() -> !;

fn panic(s: *c8) -> ! {
    eprint_s("[ERROR] ");
    eprint_s(s);
    eprint_s("\n");
    abort()
}

// -----------------------------------------------
// メモリ管理
// -----------------------------------------------

extern fn malloc(size: usize) -> *mut ();
extern fn realloc(ptr: *mut (), new_size: usize) -> *mut ();
extern fn free(ptr: *mut ());

// FIXME: 実装
struct Heap {}

fn heap_new() -> Heap {
    Heap {}
}

fn heap_drop(_heap: Heap) {}

/// `alignment * count` バイトのメモリを動的確保する。
///
/// 返されるポインタは NULL ではなく、`alignment` の倍数である。
/// 書き込まれている値は未定義。
fn heap_alloc(_heap: *mut Heap, alignment: usize, count: usize) -> *mut ()
    // ensures(p) p != 0 && (alignment != 0 && count != 0 --> p % alignment == 0)
{
    // 0 バイトの確保は malloc に要求しない。
    if (alignment | count) == 0_usize {
        return 1 as *mut ();
    }

    // 巨大なメモリの確保はエラーで落とす。
    if 1_000_000_000_usize / alignment <= count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] malloc(", (alignment * count) as i32, ")\n");
    let ptr = malloc(alignment * count);
    if ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    ptr
}

fn heap_realloc(_heap: *mut Heap, old_ptr: *mut (), alignment: usize, new_count: usize) -> *mut () {
    if (alignment | new_count) == 0_usize {
        return 1 as *mut ();
    }

    if 1_000_000_000_usize / alignment <= new_count {
        panic("OUT OF MEMORY");
    }

    eprint_sds("[TRACE] realloc(", (alignment * new_count) as i32, ")\n");
    let new_ptr = realloc(old_ptr, alignment * new_count);
    if new_ptr as usize == 0_usize {
        panic("OUT OF MEMORY");
    }

    new_ptr
}

fn heap_dealloc(_heap: *mut Heap, _ptr: *mut ()) {}

fn global_heap_init() {}

fn global_heap_deinit() {}

fn global_heap() -> *mut Heap {
    1 as *mut Heap
}

// -----------------------------------------------
// 入出力
// -----------------------------------------------

extern fn eprint_s(value: *c8);
extern fn eprint_t(value: *c8, len: usize);
extern fn eprint_d(value: i32);

fn eprint_sds(s1: *c8, d2: i32, s3: *c8) {
    eprint_s(s1);
    eprint_d(d2);
    eprint_s(s3);
}

// -----------------------------------------------
// テストフレームワーク
// -----------------------------------------------

struct TestTools {
    pass_count: usize,
    fail_count: usize,
}

fn test_tools_new() -> TestTools {
    TestTools {
        pass_count: 0_usize,
        fail_count: 0_usize,
    }
}

fn test_tools_finish(tt: TestTools) -> i32 {
    let total_count = tt.pass_count + tt.fail_count;

    eprint_sds("[TRACE] 表明数 ", total_count as i32, " / ");
    eprint_sds("成功 ", tt.pass_count as i32, " / ");
    eprint_sds("失敗 ", tt.fail_count as i32, "\n");

    if tt.fail_count > 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 一部のテストが失敗しています。\n");
        1
    } else if tt.pass_count == 0_usize {
        // 文字色: イエロー
        eprint_s("[\x1B[33mERROR\x1B[0m] 表明がありません。\n");
        1
    } else {
        // 文字色: シアン
        eprint_s("[\x1B[36mINFO]\x1B[0m OK\n");
        0
    }
}

/// 表明が通ったときに呼ばれる。
fn assert_pass(tt: *mut TestTools) {
    (*tt).pass_count += 1_usize;
}

/// 表明が落ちたときに呼ばれる。
fn assert_fail(tt: *mut TestTools) {
    (*tt).fail_count += 1_usize;

    let total_count = (*tt).pass_count + (*tt).fail_count;

    // 文字色: イエロー
    eprint_sds("[\x1B[33mERROR\x1B[0m] 表明エラー #", total_count as i32, "\n");
}

fn assert_that(tt: *mut TestTools, cond: bool, message: *c8) {
    if cond {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        eprint_s("    ");
        eprint_s(message);
        eprint_s("\n");
    }
}

fn assert_eq_i32(tt: *mut TestTools, actual: i32, expected: i32) {
    if actual == expected {
        tt |> assert_pass();
    } else {
        tt |> assert_fail();
        // 文字色: シアン
        eprint_sds("    期待された結果 \x1B[36m", expected, "\x1B[0m\n");
        // 文字色: イエロー
        eprint_sds("    実際に得た結果 \x1B[33m", actual, "\x1B[0m\n");
    }
}

fn assert_eq_usize(tt: *mut TestTools, actual: usize, expected: usize) {
    assert_eq_i32(tt, actual as i32, expected as i32);
}

// -----------------------------------------------
// 数値ライブラリ
// -----------------------------------------------

fn usize_compare(left: usize, right: usize) -> i32 {
    if left == right {
        0
    } else if left < right {
        -1
    } else {
        1
    }
}

fn usize_min(left: usize, right: usize) -> usize {
    if left < right {
        left
    } else {
        right
    }
}

fn usize_max(left: usize, right: usize) -> usize {
    if left > right {
        left
    } else {
        right
    }
}

// -----------------------------------------------
// Str
// -----------------------------------------------

extern fn strlen(str: *c8) -> usize;

/// 文字列の一部への読み取り専用の参照。
///
/// Rust の `&str`、C++ の `std::string_view` に相当。
struct Str {
    ptr: *c8,
    len: usize,
}

fn str_empty() -> Str {
    Str {
        ptr: "",
        len: 0_usize,
    }
}

fn str_from_raw(c_str: *c8) -> Str {
    Str {
        ptr: c_str,
        len: strlen(c_str),
    }
}

fn str_is_empty(s: Str) -> bool {
    s.len == 0_usize
}

fn str_slice_from(s: Str, start: usize) -> Str {
    if start >= s.len {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: s.len - start,
    }
}

fn str_slice(s: Str, start: usize, end: usize) -> Str {
    if end >= s.len {
        end = s.len;
    }

    if start >= end {
        return str_empty();
    }

    Str {
        ptr: s.ptr + start,
        len: end - start,
    }
}

fn str_compare(s: Str, other: Str) -> i32 {
    let n = usize_min(s.len, other.len);
    let p = s.ptr;
    let q = other.ptr;
    while n >= 1_usize {
        n -= 1_usize;

        if *p != *q {
            // FIXME: *p as i32 が *(p as i32) にパースされてしまう。
            return usize_compare((*p) as usize, (*q) as usize);
        }

        p += 1_usize;
        q += 1_usize;
    }
    usize_compare(s.len, other.len)
}

fn str_equals_raw(s: Str, other: *c8) -> bool {
    str_compare(s, str_from_raw(other)) == 0
}

fn str_prefix_raw(s: Str, prefix: *c8, len: *mut usize) -> bool {
    let prefix_len = strlen(prefix);
    if s.len >= prefix_len && strncmp(s.ptr, prefix, prefix_len) == 0 {
        *len = prefix_len;
        true
    } else {
        false
    }
}

fn str_tests(tt: *mut TestTools) {
    let empty = str_empty();
    let hello = str_from_raw("hello");
    assert_eq_usize(tt, hello.len, 5_usize);

    assert_that(tt, empty |> str_is_empty(), "\"\" is empty");
    assert_that(tt, !(hello |> str_is_empty()), "\"hello\" is not empty");

    let lo = str_slice_from(hello, 3_usize);
    assert_eq_usize(tt, lo.len, 2_usize);

    assert_eq_i32(tt, str_compare(str_from_raw("a"), str_from_raw("aa")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("aa"), str_from_raw("ab")), -1);
    assert_eq_i32(tt, str_compare(str_from_raw("ba"), str_from_raw("a")), 1);
    assert_eq_i32(tt, str_compare(lo, str_from_raw("lo")), 0);

    assert_eq_i32(tt, str_compare(str_slice(hello, 0_usize, 99_usize), hello), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 99_usize, 66_usize), empty), 0);
    assert_eq_i32(tt, str_compare(str_slice(hello, 1_usize, 4_usize), str_from_raw("ell")), 0);
}

// -----------------------------------------------
// StrBuf
// -----------------------------------------------

/// メモリを所有する文字列バッファ。
///
/// Rust の `String`、C++ の `std::string` に相当。
struct StrBuf {
    ptr: *mut c8,
    len: usize,
    cap: usize,
}

/// 空の StrBuf を生成する。(動的確保は発生しない。)
fn str_buf_empty() -> StrBuf {
    StrBuf {
        ptr: "" as *mut c8,
        len: 0_usize,
        cap: 0_usize,
    }
}

fn str_buf_new_with_cap(cap: usize) -> StrBuf {
    if cap == 0_usize {
        return str_buf_empty();
    }

    StrBuf {
        ptr: heap_alloc(global_heap(), 1_usize, cap) as *mut c8,
        len: 0_usize,
        cap: cap,
    }
}

fn str_buf_as_str(buf: *StrBuf) -> Str {
    Str {
        ptr: (*buf).ptr,
        len: (*buf).len,
    }
}

fn str_buf_len(buf: *StrBuf) -> usize {
    (*buf).len
}

fn str_buf_grow(buf: *mut StrBuf, new_size: usize) {
    if new_size <= (*buf).cap {
        return;
    }

    if (*buf).cap == 0_usize {
        // ptr がヒープを指していないので、realloc できない。
        (*buf).ptr = heap_alloc(global_heap(), 1_usize, new_size) as *mut c8;
    } else {
        // 再確保の回数を抑えるため、バッファサイズは指数的に増やす。
        new_size = usize_max(new_size, (*buf).cap * 2_usize);

        (*buf).ptr = heap_realloc(global_heap(), (*buf).ptr as *mut (), 1_usize, new_size) as *mut c8;
    }

    (*buf).cap = new_size;
}

fn str_buf_push_c8(buf: *mut StrBuf, c: c8) {
    str_buf_grow(buf, (*buf).len + 1_usize);

    (*buf).ptr[(*buf).len] = c;
    (*buf).len += 1_usize;
}

fn str_buf_push_str(buf: *mut StrBuf, other: Str) {
    str_buf_grow(buf, (*buf).len + other.len);

    memcpy(((*buf).ptr + (*buf).len) as *mut (), other.ptr as *(), other.len);
    (*buf).len += other.len;
}

fn str_buf_tests(tt: *mut TestTools)  {
    let s = str_buf_empty();
    // s == ""
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_empty()), 0);

    str_buf_push_c8(&mut s, 'a');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("a")), 0);

    str_buf_push_c8(&mut s, 'b');
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("ab")), 0);

    str_buf_push_str(&mut s, str_from_raw("cd"));
    assert_eq_i32(tt, str_compare(str_buf_as_str(&s), str_from_raw("abcd")), 0);
}

fn eprint_sts(s1: *c8, t2: Str, s3: *c8) {
    eprint_s(s1);
    eprint_t(t2.ptr, t2.len);
    eprint_s(s3);
}

fn assert_eq_str(tt: *mut TestTools, actual: Str, expected: Str) {
    if str_compare(actual, expected) == 0 {
        assert_pass(tt);
    } else {
        assert_fail(tt);
        // 文字色: シアン
        eprint_sts("    期待された結果 '\x1B[36m", expected, "\x1B[0m'\n");
        // 文字色: イエロー
        eprint_sts("    実際に得た結果 '\x1B[33m", actual, "\x1B[0m'\n");
    }
}

// -----------------------------------------------
// 構文
// -----------------------------------------------

/// 構文木のノードやトークンの種類
enum SyntaxKind {
    /// End of file. 入力の末尾
    Eof,
    /// 1つ以上の改行
    NewLines,
    /// 1つ以上の、改行でない空白文字
    Blank,
    /// コメント
    Comment,
    /// 数値リテラル
    Number,
    /// 文字リテラル
    Char,
    /// 文字列リテラル
    String,
    /// 識別子
    Ident,
    /// `_`
    Underscore,

    // キーワード類
    As,
    Box,
    Break,
    Case,
    Cl,
    Crate,
    Const,
    Continue,
    Default,
    Defer,
    Do,
    Dyn,
    Else,
    Enum,
    Ensures,
    Export,
    Extern,
    False,
    Fn,
    For,
    From,
    If,
    Impl,
    Import,
    In,
    Inline,
    Let,
    Loop,
    Macro,
    Match,
    Mod,
    Move,
    Mut,
    Of,
    Out,
    Priv,
    Pub,
    Raw,
    Ref,
    Requires,
    Return,
    Safe,
    SelfLower,
    Static,
    Struct,
    Super,
    Then,
    Throw,
    To,
    Trait,
    True,
    Try,
    Type,
    Union,
    Unless,
    Unsafe,
    Until,
    Use,
    Val,
    Void,
    When,
    Where,
    While,
    With,
    Yield,

    // カッコ類
    /// `(`
    LeftParen,
    /// `)`
    RightParen,
    /// `[`
    LeftBracket,
    /// `]`
    RightBracket,
    /// `{`
    LeftBrace,
    /// `}`
    RightBrace,

    // 約物
    /// `&`
    And,
    /// `&&`
    AndAnd,
    /// `&&=`
    AndAndEqual,
    /// `&=`
    AndEqual,
    /// `!`
    Bang,
    /// `!=`
    BangEqual,
    /// `!==`
    BangEqualEqual,
    /// `:`
    Colon,
    /// `::`
    ColonColon,
    /// `,`
    Comma,
    /// `.`
    Dot,
    /// `..`
    DotDot,
    /// `..=`
    DotDotEqual,
    /// `..<`
    DotDotLeft,
    /// `=`
    Equal,
    /// `==`
    EqualEqual,
    /// `===`
    EqualEqualEqual,
    /// `=>`
    EqualRight,
    /// `#`
    Hash,
    /// `#!`
    HashBang,
    /// `^`
    Hat,
    /// `^=`
    HatEqual,
    /// `<`
    LeftAngle,
    /// `<=`
    LeftEqual,
    /// `<=>`
    LeftEqualRight,
    /// `<<`
    LeftLeft,
    /// `<<=`
    LeftLeftEqual,
    /// `<<<`
    LeftLeftLeft,
    /// `<-`
    LeftMinus,
    /// `<->`
    LeftMinusRight,
    /// `-`
    Minus,
    /// `-=`
    MinusEqual,
    /// `--`
    MinusMinus,
    /// `-->`
    MinusMinusRight,
    /// `->`
    MinusRight,
    /// `%`
    Percent,
    /// `%=`
    PercentEqual,
    /// `|`
    Pipe,
    /// `|=`
    PipeEqual,
    /// `||`
    PipePipe,
    /// `||=`
    PipePipeEqual,
    /// `|>`
    PipeRight,
    /// `+`
    Plus,
    /// `+=`
    PlusEqual,
    /// `++`
    PlusPlus,
    /// `?`
    Question,
    /// `>`
    RightAngle,
    /// `>=`
    RightEqual,
    /// `>>`
    RightRight,
    /// `>>=`
    RightRightEqual,
    /// `>>>`
    RightRightRight,
    /// `;`
    Semi,
    /// `/`
    Slash,
    /// `/=`
    SlashEqual,
    /// `*`
    Star,
    /// `*=`
    StarEqual,
}

fn syntax_kind_is_leading_trivia(kind: SyntaxKind) -> bool {
    match kind {
        SyntaxKind::NewLines => true,
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trailing_trivia(kind: SyntaxKind) -> bool {
    match kind {
        SyntaxKind::Blank => true,
        SyntaxKind::Comment => true,
        _ => false,
    }
}

fn syntax_kind_is_trivia(kind: SyntaxKind) -> bool {
    syntax_kind_is_leading_trivia(kind)
}

fn syntax_kind_name(kind: SyntaxKind) -> Str {
    let name = match kind {
        SyntaxKind::Eof => "EOF",
        SyntaxKind::NewLines => "NEW_LINES",
        SyntaxKind::Blank => "BLANK",
        SyntaxKind::Comment => "COMMENT",
        SyntaxKind::Number => "NUMBER",
        SyntaxKind::Char => "CHAR",
        SyntaxKind::STRING => "STRING",
        SyntaxKind::Ident => "IDENT",
        SyntaxKind::Underscore =>"UNDERSCORE",
        SyntaxKind::As => "AS",
        SyntaxKind::Box => "BOX",
        SyntaxKind::Break => "BREAK",
        SyntaxKind::Case => "CASE",
        SyntaxKind::Cl => "CL",
        SyntaxKind::Crate => "CRATE",
        SyntaxKind::Const => "CONST",
        SyntaxKind::Continue => "CONTINUE",
        SyntaxKind::Default => "DEFAULT",
        SyntaxKind::Defer => "DEFER",
        SyntaxKind::Do => "DO",
        SyntaxKind::Dyn => "DYN",
        SyntaxKind::Else => "ELSE",
        SyntaxKind::Enum => "ENUM",
        SyntaxKind::Ensures => "ENSURES",
        SyntaxKind::Export => "EXPORT",
        SyntaxKind::Extern => "EXTERN",
        SyntaxKind::False => "FALSE",
        SyntaxKind::Fn => "FN",
        SyntaxKind::For => "FOR",
        SyntaxKind::From => "FROM",
        SyntaxKind::If => "IF",
        SyntaxKind::Impl => "IMPL",
        SyntaxKind::Import => "IMPORT",
        SyntaxKind::In => "IN",
        SyntaxKind::Inline => "INLINE",
        SyntaxKind::Let => "LET",
        SyntaxKind::Loop => "LOOP",
        SyntaxKind::Macro => "MACRO",
        SyntaxKind::Match => "MATCH",
        SyntaxKind::Mod => "MOD",
        SyntaxKind::Move => "MOVE",
        SyntaxKind::Mut => "MUT",
        SyntaxKind::Of => "OF",
        SyntaxKind::Out => "OUT",
        SyntaxKind::Priv => "PRIV",
        SyntaxKind::Pub => "PUB",
        SyntaxKind::Raw => "RAW",
        SyntaxKind::Ref => "REF",
        SyntaxKind::Requires => "REQUIRES",
        SyntaxKind::Return => "RETURN",
        SyntaxKind::Safe => "SAFE",
        SyntaxKind::SelfLower => "SELF",
        SyntaxKind::Static => "STATIC",
        SyntaxKind::Struct => "STRUCT",
        SyntaxKind::Super => "SUPER",
        SyntaxKind::Then => "THEN",
        SyntaxKind::Throw => "THROW",
        SyntaxKind::To => "TO",
        SyntaxKind::Trait => "TRAIT",
        SyntaxKind::True => "TRUE",
        SyntaxKind::Try => "TRY",
        SyntaxKind::Type => "TYPE",
        SyntaxKind::Union => "UNION",
        SyntaxKind::Unless => "UNLESS",
        SyntaxKind::Unsafe => "UNSAFE",
        SyntaxKind::Until => "UNTIL",
        SyntaxKind::Use => "USE",
        SyntaxKind::Val => "VAL",
        SyntaxKind::Void => "VOID",
        SyntaxKind::When => "WHEN",
        SyntaxKind::Where => "WHERE",
        SyntaxKind::While => "WHILE",
        SyntaxKind::With => "WITH",
        SyntaxKind::Yield => "YIELD",
        SyntaxKind::LeftParen => "(",
        SyntaxKind::RightParen => ")",
        SyntaxKind::LeftBracket => "[",
        SyntaxKind::RightBracket => "]",
        SyntaxKind::LeftBrace => "{",
        SyntaxKind::RightBrace => "}",
        SyntaxKind::And => "&",
        SyntaxKind::AndAnd => "&&",
        SyntaxKind::AndAndEqual => "&&=",
        SyntaxKind::AndEqual => "&=",
        SyntaxKind::Bang => "!",
        SyntaxKind::BangEqual => "!=",
        SyntaxKind::BangEqualEqual => "!==",
        SyntaxKind::Colon => ":",
        SyntaxKind::ColonColon => "::",
        SyntaxKind::Comma => ",",
        SyntaxKind::Dot => ".",
        SyntaxKind::DotDot => "..",
        SyntaxKind::DotDotEqual => "..=",
        SyntaxKind::DotDotLeft => "..<",
        SyntaxKind::Equal => "=",
        SyntaxKind::EqualEqual => "==",
        SyntaxKind::EqualEqualEqual => "===",
        SyntaxKind::EqualRight => "=>",
        SyntaxKind::Hash => "#",
        SyntaxKind::HashBang => "#!",
        SyntaxKind::Hat => "^",
        SyntaxKind::HatEqual => "^=",
        SyntaxKind::LeftAngle => "<",
        SyntaxKind::LeftEqual => "<=",
        SyntaxKind::LeftEqualRight => "<=>",
        SyntaxKind::LeftLeft => "<<",
        SyntaxKind::LeftLeftEqual => "<<=",
        SyntaxKind::LeftLeftLeft => "<<<",
        SyntaxKind::LeftMinus => "<-",
        SyntaxKind::LeftMinusRight => "<->",
        SyntaxKind::Minus => "-",
        SyntaxKind::MinusEqual => "-=",
        SyntaxKind::MinusMinus => "--",
        SyntaxKind::MinusMinusRight => "-->",
        SyntaxKind::MinusRight => "->",
        SyntaxKind::Percent => "%",
        SyntaxKind::PercentEqual => "%=",
        SyntaxKind::Pipe => "|",
        SyntaxKind::PipeEqual => "|=",
        SyntaxKind::PipePipe => "||",
        SyntaxKind::PipePipeEqual => "||=",
        SyntaxKind::PipeRight => "|>",
        SyntaxKind::Plus => "+",
        SyntaxKind::PlusEqual => "+=",
        SyntaxKind::PlusPlus => "++",
        SyntaxKind::Question => "?",
        SyntaxKind::RightAngle => ">",
        SyntaxKind::RightEqual => ">=",
        SyntaxKind::RightRight => ">>",
        SyntaxKind::RightRightEqual => ">>=",
        SyntaxKind::RightRightRight => ">>>",
        SyntaxKind::Semi => ";",
        SyntaxKind::Slash => "/",
        SyntaxKind::SlashEqual => "/=",
        SyntaxKind::Star => "*",
        SyntaxKind::StarEqual => "*=",
    };
    str_from_raw(name)
}

fn syntax_kind_from_ident(s: Str) -> SyntaxKind
    // requires s.len >= 1
{
    match *s.ptr {
        '_' => {
            if str_equals_raw(s, "_") {
                return SyntaxKind::Underscore;
            }
        },
        'a' => {
            if str_equals_raw(s, "as") {
                return SyntaxKind::As;
            }
        },
        'b' => {
            if str_equals_raw(s, "box") {
                return SyntaxKind::Box;
            }

            if str_equals_raw(s, "break") {
                return SyntaxKind::Break;
            }
        },
        'c' => {
            if str_equals_raw(s, "case") {
                return SyntaxKind::Case;
            }

            if str_equals_raw(s, "cl") {
                return SyntaxKind::Cl;
            }

            if str_equals_raw(s, "crate") {
                return SyntaxKind::Crate;
            }

            if str_equals_raw(s, "const") {
                return SyntaxKind::Const;
            }

            if str_equals_raw(s, "continue") {
                return SyntaxKind::Continue;
            }
        },
        'd' => {
            if str_equals_raw(s, "default") {
                return SyntaxKind::Default;
            }

            if str_equals_raw(s, "defer") {
                return SyntaxKind::Defer;
            }

            if str_equals_raw(s, "do") {
                return SyntaxKind::Do;
            }

            if str_equals_raw(s, "dyn") {
                return SyntaxKind::Dyn;
            }
        },
        'e' => {
            if str_equals_raw(s, "else") {
                return SyntaxKind::Else;
            }

            if str_equals_raw(s, "enum") {
                return SyntaxKind::Enum;
            }

            if str_equals_raw(s, "ensures") {
                return SyntaxKind::Ensures;
            }

            if str_equals_raw(s, "export") {
                return SyntaxKind::Export;
            }

            if str_equals_raw(s, "extern") {
                return SyntaxKind::Extern;
            }
        },
        'f' => {
            if str_equals_raw(s, "false") {
                return SyntaxKind::False;
            }

            if str_equals_raw(s, "fn") {
                return SyntaxKind::Fn;
            }

            if str_equals_raw(s, "for") {
                return SyntaxKind::For;
            }

            if str_equals_raw(s, "from") {
                return SyntaxKind::From;
            }
        },
        'i' => {
            if str_equals_raw(s, "if") {
                return SyntaxKind::If;
            }

            if str_equals_raw(s, "impl") {
                return SyntaxKind::Impl;
            }

            if str_equals_raw(s, "import") {
                return SyntaxKind::Import;
            }

            if str_equals_raw(s, "in") {
                return SyntaxKind::In;
            }

            if str_equals_raw(s, "inline") {
                return SyntaxKind::Inline;
            }
        },
        'l' => {
            if str_equals_raw(s, "let") {
                return SyntaxKind::Let;
            }

            if str_equals_raw(s, "loop") {
                return SyntaxKind::Loop;
            }
        },
        'm' => {
            if str_equals_raw(s, "macro") {
                return SyntaxKind::Macro;
            }

            if str_equals_raw(s, "match") {
                return SyntaxKind::Match;
            }

            if str_equals_raw(s, "mod") {
                return SyntaxKind::Mod;
            }

            if str_equals_raw(s, "move") {
                return SyntaxKind::Move;
            }

            if str_equals_raw(s, "mut") {
                return SyntaxKind::Mut;
            }
        },
        'o' => {
            if str_equals_raw(s, "of") {
                return SyntaxKind::Of;
            }

            if str_equals_raw(s, "out") {
                return SyntaxKind::Out;
            }
        },
        'p' => {
            if str_equals_raw(s, "priv") {
                return SyntaxKind::Priv;
            }

            if str_equals_raw(s, "pub") {
                return SyntaxKind::Pub;
            }
        },
        'r' => {
            if str_equals_raw(s, "raw") {
                return SyntaxKind::Raw;
            }

            if str_equals_raw(s, "ref") {
                return SyntaxKind::Ref;
            }

            if str_equals_raw(s, "requires") {
                return SyntaxKind::Requires;
            }

            if str_equals_raw(s, "return") {
                return SyntaxKind::Return;
            }
        },
        's' => {
            if str_equals_raw(s, "safe") {
                return SyntaxKind::Safe;
            }

            if str_equals_raw(s, "self") {
                return SyntaxKind::SelfLower;
            }

            if str_equals_raw(s, "static") {
                return SyntaxKind::Static;
            }

            if str_equals_raw(s, "struct") {
                return SyntaxKind::Struct;
            }

            if str_equals_raw(s, "super") {
                return SyntaxKind::Super;
            }
        },
        't' => {
            if str_equals_raw(s, "then") {
                return SyntaxKind::Then;
            }

            if str_equals_raw(s, "throw") {
                return SyntaxKind::Throw;
            }

            if str_equals_raw(s, "to") {
                return SyntaxKind::To;
            }

            if str_equals_raw(s, "trait") {
                return SyntaxKind::Trait;
            }

            if str_equals_raw(s, "true") {
                return SyntaxKind::True;
            }

            if str_equals_raw(s, "try") {
                return SyntaxKind::Try;
            }

            if str_equals_raw(s, "type") {
                return SyntaxKind::Type;
            }
        },
        'u' => {
            if str_equals_raw(s, "union") {
                return SyntaxKind::Union;
            }

            if str_equals_raw(s, "unless") {
                return SyntaxKind::Unless;
            }

            if str_equals_raw(s, "unsafe") {
                return SyntaxKind::Unsafe;
            }

            if str_equals_raw(s, "until") {
                return SyntaxKind::Until;
            }

            if str_equals_raw(s, "use") {
                return SyntaxKind::Use;
            }
        },
        'v' => {
            if str_equals_raw(s, "val") {
                return SyntaxKind::Val;
            }

            if str_equals_raw(s, "void") {
                return SyntaxKind::Void;
            }
        },
        'w' => {
            if str_equals_raw(s, "when") {
                return SyntaxKind::When;
            }

            if str_equals_raw(s, "where") {
                return SyntaxKind::Where;
            }

            if str_equals_raw(s, "while") {
                return SyntaxKind::While;
            }

            if str_equals_raw(s, "with") {
                return SyntaxKind::With;
            }
        },
        'y' => {
            if str_equals_raw(s, "yield") {
                return SyntaxKind::Yield;
            }
        },
        _ => {},
    }

    SyntaxKind::Ident
}

fn syntax_kind_parse_and_pun(s: Str, len: *mut usize) -> SyntaxKind
    // requires *s.ptr == '&'
{
    if s |> str_prefix_raw("&=", len) {
        return SyntaxKind::AndEqual;
    }

    if s |> str_prefix_raw("&&=", len) {
        return SyntaxKind::AndAndEqual;
    }

    if s |> str_prefix_raw("&&", len) {
        return SyntaxKind::AndAnd;
    }

    *len = 1_usize;
    SyntaxKind::And
}

fn syntax_kind_parse_bang_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("!==", len) {
        return SyntaxKind::BangEqualEqual;
    }

    if s |> str_prefix_raw("!=", len) {
        return SyntaxKind::BangEqual;
    }

    *len = 1_usize;
    SyntaxKind::Bang
}

fn syntax_kind_parse_colon_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("::", len) {
        return SyntaxKind::ColonColon;
    }

    *len = 1_usize;
    SyntaxKind::Colon
}

fn syntax_kind_parse_dot_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("..=", len) {
        return SyntaxKind::DotDotEqual;
    }

    if s |> str_prefix_raw("..<", len) {
        return SyntaxKind::DotDotLeft;
    }

    if s |> str_prefix_raw("..", len) {
        return SyntaxKind::DotDot;
    }

    *len = 1_usize;
    SyntaxKind::Dot
}

fn syntax_kind_parse_equal_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("=>", len) {
        return SyntaxKind::EqualRight;
    }

    if s |> str_prefix_raw("===", len) {
        return SyntaxKind::EqualEqualEqual;
    }

    if s |> str_prefix_raw("==", len) {
        return SyntaxKind::EqualEqual;
    }

    *len = 1_usize;
    SyntaxKind::Equal
}

fn syntax_kind_parse_hash_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("#!", len) {
        return SyntaxKind::HashBang;
    }

    *len = 1_usize;
    SyntaxKind::Hash
}

fn syntax_kind_parse_hat_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("^=", len) {
        return SyntaxKind::HatEqual;
    }

    *len = 1_usize;
    SyntaxKind::Hat
}

fn syntax_kind_parse_left_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("<=>", len) {
        return SyntaxKind::LeftEqualRight;
    }

    if s |> str_prefix_raw("<=", len) {
        return SyntaxKind::LeftEqual;
    }

    if s |> str_prefix_raw("<<=", len) {
        return SyntaxKind::LeftLeftEqual;
    }

    if s |> str_prefix_raw("<<<", len) {
        return SyntaxKind::LeftLeftLeft;
    }

    if s |> str_prefix_raw("<<", len) {
        return SyntaxKind::LeftLeft;
    }

    if s |> str_prefix_raw("<->", len) {
        return SyntaxKind::LeftMinusRight;
    }

    if s |> str_prefix_raw("<-", len) {
        return SyntaxKind::LeftMinus;
    }

    *len = 1_usize;
    SyntaxKind::LeftAngle
}

fn syntax_kind_parse_minus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("->", len) {
        return SyntaxKind::MinusRight;
    }

    if s |> str_prefix_raw("-=", len) {
        return SyntaxKind::MinusEqual;
    }

    if s |> str_prefix_raw("-->", len) {
        return SyntaxKind::MinusMinusRight;
    }

    if s |> str_prefix_raw("--", len) {
        return SyntaxKind::MinusMinus;
    }

    *len = 1_usize;
    SyntaxKind::Minus
}

fn syntax_kind_parse_percent_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("%=", len) {
        return SyntaxKind::PercentEqual;
    }

    *len = 1_usize;
    SyntaxKind::Percent
}

fn syntax_kind_parse_pipe_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("||=", len) {
        return SyntaxKind::PipePipeEqual;
    }

    if s |> str_prefix_raw("||", len) {
        return SyntaxKind::PipePipe;
    }

    if s |> str_prefix_raw("|>", len) {
        return SyntaxKind::PipeRight;
    }

    if s |> str_prefix_raw("|=", len) {
        return SyntaxKind::PipeEqual;
    }

    *len = 1_usize;
    SyntaxKind::Pipe
}

fn syntax_kind_parse_plus_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("+=", len) {
        return SyntaxKind::PlusEqual;
    }

    if s |> str_prefix_raw("++", len) {
        return SyntaxKind::PlusPlus;
    }

    *len = 1_usize;
    SyntaxKind::Plus
}

fn syntax_kind_parse_right_angle_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw(">>>", len) {
        return SyntaxKind::RightRightRight;
    }

    if s |> str_prefix_raw(">>=", len) {
        return SyntaxKind::RightRightEqual;
    }

    if s |> str_prefix_raw(">>", len) {
        return SyntaxKind::RightRight;
    }

    if s |> str_prefix_raw(">=", len) {
        return SyntaxKind::RightEqual;
    }

    *len = 1_usize;
    SyntaxKind::RightAngle
}

fn syntax_kind_parse_star_pun(s: Str, len: *mut usize) -> SyntaxKind {
    if s |> str_prefix_raw("*=", len) {
        return SyntaxKind::StarEqual;
    }

    *len = 1_usize;
    SyntaxKind::Star
}

struct GreenToken {
    kind: SyntaxKind,
    len: u16,
}

// -----------------------------------------------
// 字句解析
// -----------------------------------------------

struct TokenStream {
    text: Str,
    last: usize,
    current: usize,
}

fn token_stream_new(text: Str) -> TokenStream {
    TokenStream {
        text: text,
        last: 0_usize,
        current: 0_usize,
    }
}

fn token_stream_from_raw(text: *c8) -> TokenStream {
    token_stream_new(str_from_raw(text))
}

/// 前回 commit した位置から現在の位置までの文字列へのスライスを取る。
fn ts_current_str(ts: *TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).last, (*ts).current)
}

/// 現在の位置より後にある文字列へのスライスを取る。
fn ts_rest_str(ts: *mut TokenStream) -> Str {
    (*ts).text |> str_slice((*ts).current, (*ts).text.len)
}

/// 次の文字を見る。
fn ts_peek(ts: *TokenStream) -> c8 {
    if (*ts).current >= (*ts).text.len {
        return '\0';
    }

    (*ts).text.ptr[(*ts).current]
}

fn ts_bump_many(ts: *mut TokenStream, len: usize)
    // requires ts.current + len <= ts.text.len && ts.current + len is char boundary of ts.text
{
    (*ts).current += len;
}

/// 次の1文字を読み進める。
fn ts_bump(ts: *mut TokenStream)
    // requires ts.current < ts.text.len && ts.current + 1 is char boundary of ts.text
{
    // FIXME: Unicode 文字を途中で切らない
    (*ts).current += 1_usize;
}

/// 次の文字が c なら読み進める。読み進めたら true
fn ts_eat1(ts: *mut TokenStream, c: c8) -> bool {
    if ts_peek(ts) == c {
        ts_bump(ts);
        true
    } else {
        false
    }
}

fn ts_commit(ts: *mut TokenStream, kind: SyntaxKind) -> GreenToken {
    let len = (*ts).current - (*ts).last;

    (*ts).last = (*ts).current;

    GreenToken {
        kind: kind,
        len: len as u16,
    }
}

fn c8_is_new_line(c: c8) -> bool {
    match c {
        '\r' => true,
        '\n' => true,
        _ => false,
    }
}

fn c8_is_blank(c: c8) -> bool {
    match c {
        ' ' => true,
        '\t' => true,
        _ => false,
    }
}

fn c8_is_digit(c: c8) -> bool {
    '0' <= c && c <= '9'
}

fn c8_is_bit(c: c8) -> bool {
    match c {
        '0' => true,
        '1' => true,
        _ => false,
    }
}

fn c8_is_hexdigit(c: c8) -> bool {
    ('0' <= c && c <= '9') || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f')
}

fn c8_is_alphabetic(c: c8) -> bool {
    ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')
}

fn c8_is_exponential(c: c8) -> bool {
    match c {
        'e' => true,
        'E' => true,
        'p' => true,
        'P' => true,
        _ => false,
    }
}

fn c8_is_ident(c: c8) -> bool {
    // FIXME: Unicode 文字も識別子として受け付ける
    c8_is_alphabetic(c) || c8_is_digit(c) || c == '_'
}

fn scan_new_lines(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_new_line() {
        ts |> ts_bump();
    }
}

fn scan_blank(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_blank() {
        ts |> ts_bump();
    }
}

fn scan_digits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_digit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_bits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_bit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

fn scan_hexdigits(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_hexdigit() {
        ts |> ts_bump();
        ts |> ts_eat1('_');
    }
}

enum Radix {
    Decimal,
    Binary,
    Hex,
}

fn scan_digits_with_radix(ts: *mut TokenStream, radix: Radix) {
    match radix {
        Radix::Decimal => scan_digits(ts),
        Radix::Binary => scan_bits(ts),
        Radix::Hex => scan_hexdigits(ts),
    }
}

fn scan_number_with_radix(ts: *mut TokenStream, radix: Radix) {
    ts |> scan_digits_with_radix(radix);

    // 小数部
    if ts |> ts_eat1('.') {
        ts |> scan_digits_with_radix(radix);
    }

    // 指数部
    if ts |> ts_peek() |> c8_is_exponential() {
        ts |> ts_bump();

        match ts |> ts_peek() {
            '+' => ts |> ts_bump(),
            '-' => ts |> ts_bump(),
            _ => {}
        }

        ts |> scan_digits_with_radix(radix);
    }

    // 接尾辞
    ts |> scan_ident();
}

fn scan_string_contents(ts: *mut TokenStream, quote: c8) {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            '\\' => {
                ts |> ts_bump();
                ts |> ts_bump();
                continue;
            }
            '\'' => {
                if quote == '\'' {
                    break;
                }
            }
            '"' => {
                if quote == '\"' {
                    break;
                }
            }
            _ => {}
        }

        ts |> ts_bump();
    }
}

fn scan_ident(ts: *mut TokenStream) {
    while ts |> ts_peek() |> c8_is_ident() {
        ts |> ts_bump();
    }
}

fn tokenize_new_lines(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_new_lines();
    ts |> ts_commit(SyntaxKind::NewLines)
}

fn tokenize_blank(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_blank();
    ts |> ts_commit(SyntaxKind::Blank)
}

fn tokenize_comment_after_slash_slash(ts: *mut TokenStream) -> GreenToken {
    loop {
        match ts |> ts_peek() {
            '\0' => break,
            '\r' => break,
            '\n' => break,
            _ => ts |> ts_bump(),
        }
    }

    ts |> ts_commit(SyntaxKind::Comment)
}

fn tokenize_number_starting_with_zero(ts: *mut TokenStream) -> GreenToken {
    let radix = match ts |> ts_peek() {
        'b' => Radix::Binary,
        'B' => Radix::Binary,
        'x' => Radix::Hex,
        'X' => Radix::Hex,
        _ => Radix::Decimal,
    };

    if radix != Radix::Decimal {
        ts |> ts_bump(); // [bBxX]
    }

    ts |> scan_number_with_radix(radix);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_decimal(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_number_with_radix(Radix::Decimal);
    ts |> ts_commit(SyntaxKind::Number)
}

fn tokenize_char_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('\'');
    ts |> ts_eat1('\'');
    ts |> ts_commit(SyntaxKind::Char)
}

fn tokenize_string_after_quote(ts: *mut TokenStream) -> GreenToken {
    ts |> scan_string_contents('"');
    ts |> ts_eat1('"');
    ts |> ts_commit(SyntaxKind::String)
}

fn tokenize_ident_starting_with_underscore(ts: *mut TokenStream) -> GreenToken {
    if !(ts |> ts_peek() |> c8_is_ident() ){
        return ts |> ts_commit(SyntaxKind::Underscore);
    }

    ts |> scan_ident();
    ts |> ts_commit(SyntaxKind::Ident)
}

fn tokenize_ident(ts: *mut TokenStream) -> GreenToken {
    scan_ident(ts);
    let kind = ts |> ts_current_str() |> syntax_kind_from_ident();
    ts |> ts_commit(kind)
}

fn tokenize_pun(ts: *mut TokenStream, kind: SyntaxKind, len: usize) -> GreenToken {
    ts |> ts_bump_many(len);
    ts |> ts_commit(kind)
}

fn token_stream_next(ts: *mut TokenStream) -> GreenToken {
    match ts |> ts_peek() {
        '\0' => ts |> ts_commit(SyntaxKind::Eof),
        // FIXME: OR パターン
        '\r' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        '\n' => {
            ts |> ts_bump();
            ts |> tokenize_new_lines()
        },
        ' ' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '\t' => {
            ts |> ts_bump();
            ts |> tokenize_blank()
        },
        '0' => {
            ts |> ts_bump();
            ts |> tokenize_number_starting_with_zero()
        },
        '\'' => {
            ts |> ts_bump();
            ts |> tokenize_char_after_quote()
        },
        '"' => {
            ts |> ts_bump();
            ts |> tokenize_string_after_quote()
        },
        '_' => {
            ts |> ts_bump();
            ts |> tokenize_ident_starting_with_underscore()
        },
        '(' => ts |> tokenize_pun(SyntaxKind::LeftParen, 1_usize),
        ')' => ts |> tokenize_pun(SyntaxKind::RightParen, 1_usize),
        '[' => ts |> tokenize_pun(SyntaxKind::LeftBracket, 1_usize),
        ']' => ts |> tokenize_pun(SyntaxKind::RightBracket, 1_usize),
        '{' => ts |> tokenize_pun(SyntaxKind::LeftBrace, 1_usize),
        '}' => ts |> tokenize_pun(SyntaxKind::RightBrace, 1_usize),
        ',' => ts |> tokenize_pun(SyntaxKind::Comma, 1_usize),
        '?' => ts |> tokenize_pun(SyntaxKind::Question, 1_usize),
        ';' => ts |> tokenize_pun(SyntaxKind::Semi, 1_usize),
        '/' => {
            ts |> ts_bump();
            match ts |> ts_peek() {
                '/' => {
                    ts |> ts_bump();
                    ts |> tokenize_comment_after_slash_slash()
                },
                '=' => {
                    ts |> ts_bump();
                    ts |> ts_commit(SyntaxKind::SlashEqual)
                },
                _ => ts |> ts_commit(SyntaxKind::Slash),
            }
        },
        '&' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_and_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '!' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_bang_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        ':' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_colon_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '.' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_dot_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '=' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_equal_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '#' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hash_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '^' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_hat_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '<' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_left_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '-' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_minus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '%' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_percent_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '|' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_pipe_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '+' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_plus_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '>' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_right_angle_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        '*' => {
            let len = 0_usize;
            let kind = ts |> ts_rest_str() |> syntax_kind_parse_star_pun(&mut len);
            ts |> tokenize_pun(kind, len)
        },
        c => {
            if c8_is_digit(c) {
                ts |> ts_bump();
                ts |> tokenize_decimal()
            } else if c8_is_ident(c) {
                ts |> tokenize_ident()
            } else {
                // FIXME: else の後ろに書くと生成後の C コードにおいて変数 c が未定義参照になってしまう
                eprint_sds("[ERROR] unknown char ", c as i32, "\n");
                // FIXME: abort の結果を返すと void 型の変数が生成されてしまう
                abort();
                ts |> ts_commit(SyntaxKind::Eof)
            }
        }
    }
}

fn do_tokenize_dump(s: *c8, include_trivia: bool) -> StrBuf {
    let ts = token_stream_from_raw(s);
    let i = 0;
    let buf = str_buf_empty();

    loop {
        let token = token_stream_next(&mut ts);
        if token.kind == SyntaxKind::Eof {
            break;
        }

        if !include_trivia && syntax_kind_is_trivia(token.kind) {
            i += 1;
            continue;
        }

        if i != 0 {
            str_buf_push_str(&mut buf, str_from_raw(", "));
        }

        str_buf_push_str(&mut buf, syntax_kind_name(token.kind));
        i += 1;

        if i >= 10_000_000 {
            panic("字句解析が EOF に到達しないようです");
        }
    }

    buf
}

fn tokenize_dump(s: *c8) -> StrBuf {
    do_tokenize_dump(s, true)
}

fn tokenize_dump_without_trivia(s: *c8) -> StrBuf {
    do_tokenize_dump(s, false)
}

fn tokenize_tests(tt: *mut TestTools) {
    let ts = token_stream_from_raw(" \t");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Blank, "expect blank");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");
    assert_that(tt, (&mut ts |> token_stream_next()).kind == SyntaxKind::Eof, "expect eof");

    let buf = tokenize_dump("  \r\n\r\n  \n");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("BLANK, NEW_LINES, BLANK, NEW_LINES"));

    // コメント
    let buf = tokenize_dump("// 🐧LF:\n// 田CRLF:\r\n// EOF:");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("COMMENT, NEW_LINES, COMMENT, NEW_LINES, COMMENT"));

    let buf = tokenize_dump_without_trivia("1_000_000_009_i64    6.02e-23_f64    1.8p19_usize");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("NUMBER, NUMBER, NUMBER"));

    // 文字リテラル
    let buf = tokenize_dump_without_trivia("''  'a'  '\\''");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("CHAR, CHAR, CHAR"));

    // 文字列リテラル
    let buf = tokenize_dump_without_trivia("\"\"  \"I'm a string!\"  \"\\\"\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, STRING, STRING"));

    // 文字列リテラルは 改行や EOF で停止する。
    let buf = tokenize_dump("\"\n\n\"");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("STRING, NEW_LINES, STRING"));

    let buf = tokenize_dump("_0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("IDENT"));

    let buf = tokenize_dump_without_trivia("_ __");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("UNDERSCORE, IDENT"));

    // キーワード
    let buf = tokenize_dump_without_trivia("as assign in inline self Self SELF");
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw("AS, IDENT, IN, INLINE, SELF, IDENT, IDENT"));

    // 記号類
    let buf = tokenize_dump_without_trivia("||= || |> |= | >>> >>= >> >= > => === == = <=> <= <<= <<< << <-> <- < += ++ + ^= ^ %= % #! # &= &&= && & /= / *= * } { ] [ ) ( ..= ..< .. . ? !== != ! :: : ; , -> -= --> -- -");
    let expected = "||=, ||, |>, |=, |, >>>, >>=, >>, >=, >, =>, ===, ==, =, <=>, <=, <<=, <<<, <<, <->, <-, <, +=, ++, +, ^=, ^, %=, %, #!, #, &=, &&=, &&, &, /=, /, *=, *, }, {, ], [, ), (, ..=, ..<, .., ., ?, !==, !=, !, ::, :, ;, ,, ->, -=, -->, --, -";
    assert_eq_str(tt, str_buf_as_str(&buf), str_from_raw(expected));
}

// -----------------------------------------------
// エントリポイント
// -----------------------------------------------

/// テストを実行して、結果コードを返す。
pub fn libjacco_syntax_tests() -> i32 {
    global_heap_init();

    let tt = test_tools_new();
    eprint_s("[TRACE] テストの実行を開始します。\n")

    // FIXME: ブロック文が使えないので if true で代用。
    if true {
        let tt = &mut tt;
        assert_eq_i32(tt, 40 + 2, 42);
        // assert_eq_i32(tt, 40 - 2, 42);

        str_tests(tt);
        str_buf_tests(tt);
        tokenize_tests(tt);
    }

    eprint_s("[TRACE] テストの実行が終了しました。\n");
    let exit_code = test_tools_finish(tt);

    global_heap_deinit();
    exit_code
}
